
# SQL 튜닝 예상문제 모범답안 (요약 + 확장)

- 표기
    - ✅ 모범답안: 시험 답안에 바로 쓰기 좋은 짧은 서술
    - 💡 확장답안: 예시, 힌트, 주의사항

---

## 1장. SQL 처리 과정과 I/O

### 1) 구조적·집합적·선언적

- ✅ 모범답안
    - 구조적: 테이블/열/관계라는 구조에 맞춰 질의를 표현한다.
    - 집합적: 행 단위가 아닌 “조건을 만족하는 집합” 대상으로 연산한다.
    - 선언적: 원하는 결과만 기술하고 실행 절차는 옵티마이저가 결정한다.
- 💡 확장답안
    - 같은 결과라도 NL/해시/풀스캔 등 다양한 플랜 가능 → 통계·환경이 선택을 좌우.

---

### 2) 파싱·최적화·실행과 병목

- ✅ 모범답안
    - 파싱: 문법/의미 분석, 객체·권한 확인. 병목: 라이브러리 캐시 경합.
    - 최적화: 후보 플랜 탐색·비용 평가. 병목: 통계 부정확으로 오판.
    - 실행: 선택 플랜대로 Row Source 처리. 병목: 과도한 I/O·소트.
- 💡 확장답안
    - 하드파싱 절감: 바인드 변수, PreparedStatement, 커서 재사용, session_cached_cursors.

---

### 3) CBO 비용의 핵심 입력

- ✅ 모범답안
    - 통계(카디널리티, NDV, 히스토그램), I/O·CPU 비용 모델, 병렬도, 옵티마이저 파라미터.
- 💡 확장답안
    - 카디널리티 추정이 조인 순서/메소드 결정의 출발점.
    - 예: optimizer_index_cost_adj, db_file_multiblock_read_count 등 환경값 영향.

---

### 4) 고객별 최근 10건 조회 튜닝

- ✅ 모범답안
    - 인덱스: (customer_id, order_date DESC) → 소트 생략·부분범위 처리.
    - 힌트: `/*+ INDEX_DESC(orders IDX_ORD_CID_DT) */` + `FETCH FIRST 10 ROWS ONLY`.
- 💡 확장답안
    - 커버링을 위해 필요한 컬럼까지 인덱스에 포함하면 테이블 액세스 제거.
    - 예: `(customer_id, order_date DESC, amount, status)`.

---

### 5) “Cost 낮으면 항상 빠르다?” → X

- ✅ 모범답안
    - 비용은 추정치다. 통계오류·캐시상태·병렬·스토리지 영향으로 실제 시간과 어긋날 수 있다.
- 💡 확장답안
    - 같은 플랜이라도 캐시 히트율/Temp 스필 여부에 따라 성능 차이 큼.

---

### 6) 소프트 vs 하드 파싱, 절감법

- ✅ 모범답안
    - 소프트: 기존 커서 재사용. 하드: 새 커서 생성·최적화 포함.
    - 하드파싱 절감: 바인드 변수, PreparedStatement/커서 재사용, 커서 공유 설정.
- 💡 확장답안
    - `WHERE id=:1`(바인드)은 커서 공유 가능, `WHERE id=123`(리터럴)은 커서 난립.

---

### 7) 논리/물리 I/O, Single/Multi, 시퀀셜/랜덤

- ✅ 모범답안
    - 논리 I/O: 버퍼캐시 블록 접근, 물리 I/O: 디스크 읽기.
    - Single: 1블록(인덱스/랜덤), Multi: 여러 블록(풀스캔).
    - 시퀀셜: 연속 블록, 랜덤: 불연속 점프.
- 💡 확장답안
    - 인덱스 레인지 스캔은 보통 Single+랜덤, 테이블 풀스캔은 Multiblock+시퀀셜.

---

### 8) Table Full Scan vs Index Range Scan

- ✅ 모범답안
    - 풀스캔: 낮은 선택도·대량 처리·멀티블록 I/O 유리.
    - 레인지: 높은 선택도·정렬 생략·커버링 가능하나 랜덤 테이블 액세스 발생.
    - 판단: 선택도, 클러스터링 팩터, 정렬/커버링 여부.
- 💡 확장답안
    - 병렬 처리·Direct Path 읽기 가능성도 풀스캔 선택 근거.

---

## 2장. 인덱스 기본

### 9) B+Tree 구조와 수직/수평 탐색

- ✅ 모범답안
    - Root/Branch: 경로 결정, Leaf: 키+ROWID 저장.
    - 수직: Root→Leaf 진입, 수평: Leaf 체인 따라 범위 스캔.
- 💡 확장답안
    - 리프는 정렬돼 있어 ORDER BY 생략의 근거가 된다(인덱스 순서 이용).

---

### 10) Range Scan이 안 되는 경우

- ✅ 모범답안
    - 정답 C: 컬럼을 함수로 가공하면 비SARG라 Range Scan 불가.
- 💡 확장답안
    - 대안: 함수기반 인덱스 생성(예: `create index on t(to_char(col1))`).

---

### 11) 인덱스로 ORDER BY 생략 조건

- ✅ 모범답안
    - 정렬 컬럼이 인덱스 선두부터 같은 방향, WHERE로 범위 제한.
    - 예: `idx(dept_id, hire_date desc)` + `WHERE dept_id=:d` + `ORDER BY hire_date desc`.
- 💡 확장답안
    - `NULLS FIRST/LAST` 기본값이 인덱스 정렬과 다르면 소트 발생 → 명시해서 맞추기.

---

### 12) Index Full Scan vs Fast Full Scan

- ✅ 모범답안
    - Full: 리프 체인 순서 유지, 주로 Single I/O.
    - Fast Full: 인덱스 전체를 멀티블록 임의 읽기, 순서 미보장, 병렬/버퍼캐시 우회 가능.
- 💡 확장답안
    - Fast Full은 “인덱스 기반 풀스캔”으로 `count(*)` 등 커버링 집계에 유용.

---

### 13) 선두 컬럼 없이 인덱스 활용

- ✅ 모범답안
    - Index Skip Scan 사용, 선두 컬럼 NDV가 작을수록 효과적.
- 💡 확장답안
    - 힌트: `/*+ INDEX_SS(t idx_ab) */`. 혹은 새 인덱스 `(b)` 또는 `(b,a)` 설계.

---

## 3장. 인덱스 튜닝

### 14) 테이블 랜덤 액세스 최소화

- ✅ 모범답안
    - 커버링 인덱스, 손익분기점 넘으면 풀스캔, 파티셔닝/클러스터링 팩터 개선.
- 💡 확장답안
    - IOT(인덱스 조직 테이블), 클러스터 테이블로 물리적 군집 개선 고려.

---

### 15) 인덱스 손익분기점

- ✅ 모범답안
    - “인덱스 범위+랜덤 테이블 액세스 비용 ≥ 풀스캔 멀티블록 비용”이면 풀스캔이 유리.
- 💡 확장답안
    - 경험칙: 비군집 인덱스는 선택도 몇 % 이상이면 풀스캔(환경·CF 따라 2~10% 수준).

---

### 16) “인덱스만 읽고 처리” 설계

- ✅ 모범답안
    - WHERE/SELECT/ORDER BY 컬럼을 모두 포함하는 결합 인덱스로 커버링.
- 💡 확장답안
    - 예: 정렬 보고서 → `(dept_id, score desc, emp_name)` 인덱스.

---

### 17) “미결 최근 20건” 튜닝

- ✅ 모범답안
    - 인덱스 `(acct_id, status, tran_dt desc)` + `/*+ INDEX_DESC */` + `FETCH FIRST 20`.
- 💡 확장답안
    - 상태값 편중이 크면 bitmap index(status)나 함수기반 인덱스(`status='O'`)도 고려.

---

## 3.3 스캔 효율화

### 18) 액세스 조건 vs 필터 조건

- ✅ 모범답안
    - 액세스: 인덱스 탐색에 사용(`col1=:b1`).
    - 필터: 스캔 후 거름(`col2>10`).
- 💡 확장답안
    - DBMS_XPLAN의 Predicate Information에서 ACCESS/FILTER로 구분 확인.

---

### 19) IN은 ‘=’인가?

- ✅ 모범답안
    - 내부적으로 다중 ‘=’ OR로 확장(IN-List Iterator). 값이 많으면 비효율·추정오차 가능.
- 💡 확장답안
    - 값이 매우 많으면 임시 테이블 조인(세미조인)이나 바인드 배열 처리 고려.

---

### 20) BETWEEN ↔ IN 전환

- ✅ 모범답안
    - 이산 소수 값이면 IN 유리, 연속·넓은 범위면 BETWEEN 유리.
- 💡 확장답안
    - 날짜 디멘전과 조인해 특정 일자 집합으로 바꾸면 인덱스 효율↑ 가능.

---

### 21) LIKE 인덱스 영향과 대안

- ✅ 모범답안
    - `'ABC%'`: Range Scan 가능. `'%ABC'`: 불가.
    - 대안: 역함수/함수기반 인덱스, Text Index 등.
- 💡 확장답안
    - 접미 검색은 Oracle Text(CTXCAT/CONTEXT) 권장. 역순 인덱스는 접미 검색엔 근본해결 아님.

---

## 4장. 조인 튜닝

### 22) NL/SMJ/Hash 조인 비교

- ✅ 모범답안
    - NL: 선행 소량+후행 인덱스 있을 때 최적.
    - SMJ: 양쪽 정렬 후 병합, 범위조인·정렬 입력 유리.
    - Hash: 빌드→프로브, 대용량·낮은 선택도·병렬 유리.
- 💡 확장답안
    - 해시 조인은 PGA 부족 시 Temp 스필 → I/O 급증.

---

### 23) NL 조인 강제와 인덱스

- ✅ 모범답안
    - 힌트: `/*+ LEADING(C) USE_NL(O) INDEX(O IDX_O_CUST) */`
    - 후행 O에 `customer_id` 인덱스 필요.
- 💡 확장답안
    - `/*+ ORDERED */`로 FROM 순서 고정 가능. 조인 컬럼 정렬·선두 여부 점검.

---

### 24) View Merging은 항상? → X

- ✅ 모범답안
    - `DISTINCT/GROUP BY/분석함수` 등은 머지 제한. `MERGE/NO_MERGE` 힌트로 제어.
- 💡 확장답안
    - `/*+ MATERIALIZE */`로 인라인 뷰 물질화 강제해 재사용/정렬비용 최적화하기도 함.

---

### 25) NL이 해시보다 유리한 패턴

- ✅ 모범답안
    - 선행 집합이 매우 작아질 때, 후행에 적절한 인덱스가 있을 때.
- 💡 확장답안
    - 스타 스키마: 강한 필터의 차원→사실 테이블 NL이 전형적.

---

## 5장. 소트 튜닝

### 26) Sort 수행 흐름(PGA/Temp)

- ✅ 모범답안
    - PGA에서 정렬, 부족하면 Temp로 스필 후 외부 머지. Temp는 디스크 작업 공간.
- 💡 확장답안
    - 자동 워크에어리어(`workarea_size_policy=auto`), `pga_aggregate_target/limit`이 영향.

---

### 27) 소트 없애기(예제)

- ✅ 모범답안
    - `WHERE dept_id=:d`면 `GROUP BY/ORDER BY` 생략 가능.
    - 또는 인덱스 `(dept_id)`로 Group By/Order By 생략 유도.
- 💡 확장답안
    - Group By 소트 생략: 인덱스 선두가 그룹 컬럼이며 같은 방향일 때 성립.

---

### 28) UNION vs UNION ALL

- ✅ 모범답안
    - UNION: 중복 제거 위해 Sort/Hash 필요 → 느림.
    - UNION ALL: 단순 합치기 → 빠름. 중복 의미 없을 때 사용.
- 💡 확장답안
    - 중복 제거가 필요하면 각 소스에서 미리 필터/집계를 적용해 입력량을 줄이기.

---

### 29) Top-N 소트 부하 절감

- ✅ 모범답안
    - 정렬 인덱스 + `INDEX DESC` 스캔 + `FETCH FIRST N`.
    - 필요한 컬럼만 선택해 메모리 사용 축소.
- 💡 확장답안
    - 대안: `ROW_NUMBER() OVER(ORDER BY ...)` + `rn<=N`. 인덱스로 정렬 생략을 동시에 노려라.

---

## 6장. DML 튜닝

### 30) Direct Path Insert

- ✅ 모범답안
    - 버퍼캐시 우회, HWM 위 연속 할당, 병렬/`APPEND` 가능.
    - 주의: 제약/트리거/인덱스 비용, 로깅 설정.
- 💡 확장답안
    - 예: `insert /*+ APPEND */ into t select ...;`
    - 대량 적재 시 `nologging`·아카이브 정책 영향 검토.

---

### 31) Array Processing/JDBC 배치

- ✅ 모범답안
    - 여러 행을 한 번의 Call로 전송해 Call 수 감소.
    - JDBC: `addBatch/executeBatch`, 적정 배치 크기.
- 💡 확장답안
    - 예:
        
        Java
        
        ```
        conn.setAutoCommit(false);
        PreparedStatement ps = conn.prepareStatement(sql);
        for (...) { /* setXxx */ ps.addBatch(); }
        ps.executeBatch(); conn.commit();
        ```
        

---

### 32) 대량 DELETE(파티션)

- ✅ 모범답안
    - 파티션 `DROP/TRUNCATE`, `EXCHANGE PARTITION` 등 메타데이터 연산으로 대체.
    - 또는 파티션 프루닝으로 대상 축소.
- 💡 확장답안
    - 인덱스도 파티션드로 설계하면 DML/유지보수 비용 크게 감소.

---

### 33) Lock과 동시성

- ✅ 모범답안
    - TX(행), TM(테이블), DDL 락. MVCC로 일관 읽기 제공.
- 💡 확장답안
    - 행잠금 경합 이벤트: `enq: TX - row lock contention`.
    - 원인: 긴 트랜잭션, 인덱스 미스매치로 과도한 동시 업데이트 등.

---

### 34) 시퀀스 채번 성능

- ✅ 모범답안
    - `CACHE`가 I/O·경합 감소로 유리, `NOCACHE`는 느림.
    - `ORDER`(RAC)는 순서 보장 대가로 경합↑.
- 💡 확장답안
    - 권장: `cache 100~1000`, `noorder`(단일 인스턴스), 애플리케이션에서 번호 갭 허용.

---

## 7장. SQL 옵티마이저

### 35) 선택도·카디널리티 계산

- ✅ 모범답안
    - 선택도 = 조건 만족 비율, 카디널리티 = 예상 행수.
    - 예: 총 1M행, NDV=100, `col=:x` → 선택도 1/100, 카디널리티 10,000.
- 💡 확장답안
    - 다중 컬럼 상관관계는 기본 통계로 오차 큼 → 확장 통계(extended stats)·히스토그램 필요.

---

### 36) 통계 부정확 시 현상/대응

- ✅ 모범답안
    - 현상: 잘못된 조인 순서/메소드, 인덱스·풀스캔 오판.
    - 대응: `dbms_stats` 갱신, 히스토그램, 동적 샘플링, 힌트/Plan Baseline.
- 💡 확장답안
    - `METHOD_OPT 'FOR COLUMNS SIZE SKEWONLY'`, `PUBLISH/NO_INVALIDATE` 등 옵션 활용.

---

### 37) 옵티마이저 모드

- ✅ 모범답안
    - 오답 C: RULE은 기본/권장 아님.
    - `ALL_ROWS`=처리량 최적화, `FIRST_ROWS(n)`=초기 응답 최적화.
- 💡 확장답안
    - 세션/문장 단위로 힌트 제어:
        
        SQL
        
        ```
        /*+ OPTIMIZER_FEATURES_ENABLE('19.1.0') FIRST_ROWS(10) */
        ```
        

---

## 부록. SQL 분석 도구

### 38) 실행계획 확인 3가지+

- ✅ 모범답안
    - `EXPLAIN PLAN`(추정), `AUTOTRACE`(실행+통계),
    - `DBMS_XPLAN.DISPLAY_CURSOR`(실제 실행 후),
    - 실시간 SQL 모니터링(장시간 SQL 추적).
- 💡 확장답안
    - 사용 예:
        
        SQL
        
        ```
        explain plan for <sql>;
        select * from table(dbms_xplan.display);
        
        select * from table(dbms_xplan.display_cursor(null, null, 'ALLSTATS LAST'));
        ```
        

---

### 39) Predicate Information 읽기

- ✅ 모범답안
    - ACCESS: 인덱스 접근 조건, FILTER: 스캔 후 거르는 조건.
- 💡 확장답안
    - 예: `ACCESS("T"."A"=:B1)` → 루트/브랜치 탐색 키,  
        `FILTER("T"."B">10)` → 리프 범위 내에서 추가 필터.

---

### 40) V$SQL로 문제 SQL 찾기

- ✅ 모범답안
    - `V$SQLAREA/STAT`로 상위 리소스 SQL 식별 → `SQL_ID`로 CHILD/PLAN 확인 → `DBMS_XPLAN`으로 실제 플랜·바인드 확인.
- 💡 확장답안
    - 예:
        
        SQL
        
        ```
        select sql_id, executions, buffer_gets, disk_reads
        from v$sqlarea
        order by buffer_gets desc
        fetch first 20 rows only;
        
        select * from table(dbms_xplan.display_cursor('&sql_id', null, 'ALLSTATS LAST +PEEKED_BINDS'));
        ```