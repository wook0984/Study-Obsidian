
# SQL 튜닝 예상문제 모범답안 (요약 + 확장)

- 표기
    - ✅ 모범답안: 시험 답안에 바로 쓰기 좋은 짧은 서술
    - 💡 확장답안: 예시, 힌트, 주의사항

---

## 1장. SQL 처리 과정과 I/O

### 1) 구조적·집합적·선언적

- ✅ 모범답안
    - 구조적: 테이블/열/관계라는 구조에 맞춰 질의를 표현한다.
    - 집합적: 행 단위가 아닌 “조건을 만족하는 집합” 대상으로 연산한다.
    - 선언적: 원하는 결과만 기술하고 실행 절차는 옵티마이저가 결정한다.
- 💡 확장답안
    - 같은 결과라도 NL/해시/풀스캔 등 다양한 플랜 가능 → 통계·환경이 선택을 좌우.

---

### 2) 파싱·최적화·실행과 병목

- ✅ 모범답안
    - 파싱: 문법/의미 분석, 객체·권한 확인. 병목: 라이브러리 캐시 경합.
    - 최적화: 후보 플랜 탐색·비용 평가. 병목: 통계 부정확으로 오판.
    - 실행: 선택 플랜대로 Row Source 처리. 병목: 과도한 I/O·소트.
- 💡 확장답안
    - 하드파싱 절감: 바인드 변수, PreparedStatement, 커서 재사용, session_cached_cursors.

---

### 3) CBO 비용의 핵심 입력

- ✅ 모범답안
    - 통계(카디널리티, NDV, 히스토그램), I/O·CPU 비용 모델, 병렬도, 옵티마이저 파라미터.
- 💡 확장답안
    - 카디널리티 추정이 조인 순서/메소드 결정의 출발점.
    - 예: optimizer_index_cost_adj, db_file_multiblock_read_count 등 환경값 영향.

---

### 4) 고객별 최근 10건 조회 튜닝

- ✅ 모범답안
    - 인덱스: (customer_id, order_date DESC) → 소트 생략·부분범위 처리.
    - 힌트: `/*+ INDEX_DESC(orders IDX_ORD_CID_DT) */` + `FETCH FIRST 10 ROWS ONLY`.
- 💡 확장답안
    - 커버링을 위해 필요한 컬럼까지 인덱스에 포함하면 테이블 액세스 제거.
    - 예: `(customer_id, order_date DESC, amount, status)`.

---

### 5) “Cost 낮으면 항상 빠르다?” → X

- ✅ 모범답안
    - 비용은 추정치다. 통계오류·캐시상태·병렬·스토리지 영향으로 실제 시간과 어긋날 수 있다.
- 💡 확장답안
    - 같은 플랜이라도 캐시 히트율/Temp 스필 여부에 따라 성능 차이 큼.

---

### 6) 소프트 vs 하드 파싱, 절감법

- ✅ 모범답안
    - 소프트: 기존 커서 재사용. 하드: 새 커서 생성·최적화 포함.
    - 하드파싱 절감: 바인드 변수, PreparedStatement/커서 재사용, 커서 공유 설정.
- 💡 확장답안
    - `WHERE id=:1`(바인드)은 커서 공유 가능, `WHERE id=123`(리터럴)은 커서 난립.

---

### 7) 논리/물리 I/O, Single/Multi, 시퀀셜/랜덤

- ✅ 모범답안
    - 논리 I/O: 버퍼캐시 블록 접근, 물리 I/O: 디스크 읽기.
    - Single: 1블록(인덱스/랜덤), Multi: 여러 블록(풀스캔).
    - 시퀀셜: 연속 블록, 랜덤: 불연속 점프.
- 💡 확장답안
    - 인덱스 레인지 스캔은 보통 Single+랜덤, 테이블 풀스캔은 Multiblock+시퀀셜.

---

### 8) Table Full Scan vs Index Range Scan

- ✅ 모범답안
    - 풀스캔: 낮은 선택도·대량 처리·멀티블록 I/O 유리.
    - 레인지: 높은 선택도·정렬 생략·커버링 가능하나 랜덤 테이블 액세스 발생.
    - 판단: 선택도, 클러스터링 팩터, 정렬/커버링 여부.
- 💡 확장답안
    - 병렬 처리·Direct Path 읽기 가능성도 풀스캔 선택 근거.

---

## 2장. 인덱스 기본

### 9) B+Tree 구조와 수직/수평 탐색

- ✅ 모범답안
    - Root/Branch: 경로 결정, Leaf: 키+ROWID 저장.
    - 수직: Root→Leaf 진입, 수평: Leaf 체인 따라 범위 스캔.
- 💡 확장답안
    - 리프는 정렬돼 있어 ORDER BY 생략의 근거가 된다(인덱스 순서 이용).

---

### 10) Range Scan이 안 되는 경우

- ✅ 모범답안
    - 정답 C: 컬럼을 함수로 가공하면 비SARG라 Range Scan 불가.
- 💡 확장답안
    - 대안: 함수기반 인덱스 생성(예: `create index on t(to_char(col1))`).

---

### 11) 인덱스로 ORDER BY 생략 조건

- ✅ 모범답안
    - 정렬 컬럼이 인덱스 선두부터 같은 방향, WHERE로 범위 제한.
    - 예: `idx(dept_id, hire_date desc)` + `WHERE dept_id=:d` + `ORDER BY hire_date desc`.
- 💡 확장답안
    - `NULLS FIRST/LAST` 기본값이 인덱스 정렬과 다르면 소트 발생 → 명시해서 맞추기.

---

### 12) Index Full Scan vs Fast Full Scan

- ✅ 모범답안
    - Full: 리프 체인 순서 유지, 주로 Single I/O.
    - Fast Full: 인덱스 전체를 멀티블록 임의 읽기, 순서 미보장, 병렬/버퍼캐시 우회 가능.
- 💡 확장답안
    - Fast Full은 “인덱스 기반 풀스캔”으로 `count(*)` 등 커버링 집계에 유용.

---

### 13) 선두 컬럼 없이 인덱스 활용

- ✅ 모범답안
    - Index Skip Scan 사용, 선두 컬럼 NDV가 작을수록 효과적.
- 💡 확장답안
    - 힌트: `/*+ INDEX_SS(t idx_ab) */`. 혹은 새 인덱스 `(b)` 또는 `(b,a)` 설계.

---

## 3장. 인덱스 튜닝

### 14) 테이블 랜덤 액세스 최소화

- ✅ 모범답안
    - 커버링 인덱스, 손익분기점 넘으면 풀스캔, 파티셔닝/클러스터링 팩터 개선.
- 💡 확장답안
    - IOT(인덱스 조직 테이블), 클러스터 테이블로 물리적 군집 개선 고려.

---

### 15) 인덱스 손익분기점

- ✅ 모범답안
    - “인덱스 범위+랜덤 테이블 액세스 비용 ≥ 풀스캔 멀티블록 비용”이면 풀스캔이 유리.
- 💡 확장답안
    - 경험칙: 비군집 인덱스는 선택도 몇 % 이상이면 풀스캔(환경·CF 따라 2~10% 수준).

---

### 16) “인덱스만 읽고 처리” 설계

- ✅ 모범답안
    - WHERE/SELECT/ORDER BY 컬럼을 모두 포함하는 결합 인덱스로 커버링.
- 💡 확장답안
    - 예: 정렬 보고서 → `(dept_id, score desc, emp_name)` 인덱스.

---

### 17) “미결 최근 20건” 튜닝

- ✅ 모범답안
    - 인덱스 `(acct_id, status, tran_dt desc)` + `/*+ INDEX_DESC */` + `FETCH FIRST 20`.
- 💡 확장답안
    - 상태값 편중이 크면 bitmap index(status)나 함수기반 인덱스(`status='O'`)도 고려.

---

## 3.3 스캔 효율화

### 18) 액세스 조건 vs 필터 조건

- ✅ 모범답안
    - 액세스: 인덱스 탐색에 사용(`col1=:b1`).
    - 필터: 스캔 후 거름(`col2>10`).
- 💡 확장답안
    - DBMS_XPLAN의 Predicate Information에서 ACCESS/FILTER로 구분 확인.

---

### 19) IN은 ‘=’인가?

- ✅ 모범답안
    - 내부적으로 다중 ‘=’ OR로 확장(IN-List Iterator). 값이 많으면 비효율·추정오차 가능.
- 💡 확장답안
    - 값이 매우 많으면 임시 테이블 조인(세미조인)이나 바인드 배열 처리 고려.

---

### 20) BETWEEN ↔ IN 전환

- ✅ 모범답안
    - 이산 소수 값이면 IN 유리, 연속·넓은 범위면 BETWEEN 유리.
- 💡 확장답안
    - 날짜 디멘전과 조인해 특정 일자 집합으로 바꾸면 인덱스 효율↑ 가능.

---

### 21) LIKE 인덱스 영향과 대안

- ✅ 모범답안
    - `'ABC%'`: Range Scan 가능. `'%ABC'`: 불가.
    - 대안: 역함수/함수기반 인덱스, Text Index 등.
- 💡 확장답안
    - 접미 검색은 Oracle Text(CTXCAT/CONTEXT) 권장. 역순 인덱스는 접미 검색엔 근본해결 아님.

---

## 4장. 조인 튜닝

### 22) NL/SMJ/Hash 조인 비교

- ✅ 모범답안
    - NL: 선행 소량+후행 인덱스 있을 때 최적.
    - SMJ: 양쪽 정렬 후 병합, 범위조인·정렬 입력 유리.
    - Hash: 빌드→프로브, 대용량·낮은 선택도·병렬 유리.
- 💡 확장답안
    - 해시 조인은 PGA 부족 시 Temp 스필 → I/O 급증.

---

### 23) NL 조인 강제와 인덱스

- ✅ 모범답안
    - 힌트: `/*+ LEADING(C) USE_NL(O) INDEX(O IDX_O_CUST) */`
    - 후행 O에 `customer_id` 인덱스 필요.
- 💡 확장답안
    - `/*+ ORDERED */`로 FROM 순서 고정 가능. 조인 컬럼 정렬·선두 여부 점검.

---

### 24) View Merging은 항상? → X

- ✅ 모범답안
    - `DISTINCT/GROUP BY/분석함수` 등은 머지 제한. `MERGE/NO_MERGE` 힌트로 제어.
- 💡 확장답안
    - `/*+ MATERIALIZE */`로 인라인 뷰 물질화 강제해 재사용/정렬비용 최적화하기도 함.

---

### 25) NL이 해시보다 유리한 패턴

- ✅ 모범답안
    - 선행 집합이 매우 작아질 때, 후행에 적절한 인덱스가 있을 때.
- 💡 확장답안
    - 스타 스키마: 강한 필터의 차원→사실 테이블 NL이 전형적.

---

## 5장. 소트 튜닝

### 26) Sort 수행 흐름(PGA/Temp)

- ✅ 모범답안
    - PGA에서 정렬, 부족하면 Temp로 스필 후 외부 머지. Temp는 디스크 작업 공간.
- 💡 확장답안
    - 자동 워크에어리어(`workarea_size_policy=auto`), `pga_aggregate_target/limit`이 영향.

---

### 27) 소트 없애기(예제)

- ✅ 모범답안
    - `WHERE dept_id=:d`면 `GROUP BY/ORDER BY` 생략 가능.
    - 또는 인덱스 `(dept_id)`로 Group By/Order By 생략 유도.
- 💡 확장답안
    - Group By 소트 생략: 인덱스 선두가 그룹 컬럼이며 같은 방향일 때 성립.

---

### 28) UNION vs UNION ALL

- ✅ 모범답안
    - UNION: 중복 제거 위해 Sort/Hash 필요 → 느림.
    - UNION ALL: 단순 합치기 → 빠름. 중복 의미 없을 때 사용.
- 💡 확장답안
    - 중복 제거가 필요하면 각 소스에서 미리 필터/집계를 적용해 입력량을 줄이기.

---

### 29) Top-N 소트 부하 절감

- ✅ 모범답안
    - 정렬 인덱스 + `INDEX DESC` 스캔 + `FETCH FIRST N`.
    - 필요한 컬럼만 선택해 메모리 사용 축소.
- 💡 확장답안
    - 대안: `ROW_NUMBER() OVER(ORDER BY ...)` + `rn<=N`. 인덱스로 정렬 생략을 동시에 노려라.

---

## 6장. DML 튜닝

### 30) Direct Path Insert

- ✅ 모범답안
    - 버퍼캐시 우회, HWM 위 연속 할당, 병렬/`APPEND` 가능.
    - 주의: 제약/트리거/인덱스 비용, 로깅 설정.
- 💡 확장답안
    - 예: `insert /*+ APPEND */ into t select ...;`
    - 대량 적재 시 `nologging`·아카이브 정책 영향 검토.

---

### 31) Array Processing/JDBC 배치

- ✅ 모범답안
    - 여러 행을 한 번의 Call로 전송해 Call 수 감소.
    - JDBC: `addBatch/executeBatch`, 적정 배치 크기.
- 💡 확장답안
    - 예:
        
        Java
        
        ```
        conn.setAutoCommit(false);
        PreparedStatement ps = conn.prepareStatement(sql);
        for (...) { /* setXxx */ ps.addBatch(); }
        ps.executeBatch(); conn.commit();
        ```
        

---

### 32) 대량 DELETE(파티션)

- ✅ 모범답안
    - 파티션 `DROP/TRUNCATE`, `EXCHANGE PARTITION` 등 메타데이터 연산으로 대체.
    - 또는 파티션 프루닝으로 대상 축소.
- 💡 확장답안
    - 인덱스도 파티션드로 설계하면 DML/유지보수 비용 크게 감소.

---

### 33) Lock과 동시성

- ✅ 모범답안
    - TX(행), TM(테이블), DDL 락. MVCC로 일관 읽기 제공.
- 💡 확장답안
    - 행잠금 경합 이벤트: `enq: TX - row lock contention`.
    - 원인: 긴 트랜잭션, 인덱스 미스매치로 과도한 동시 업데이트 등.

---

### 34) 시퀀스 채번 성능

- ✅ 모범답안
    - `CACHE`가 I/O·경합 감소로 유리, `NOCACHE`는 느림.
    - `ORDER`(RAC)는 순서 보장 대가로 경합↑.
- 💡 확장답안
    - 권장: `cache 100~1000`, `noorder`(단일 인스턴스), 애플리케이션에서 번호 갭 허용.

---

## 7장. SQL 옵티마이저

### 35) 선택도·카디널리티 계산

- ✅ 모범답안
    - 선택도 = 조건 만족 비율, 카디널리티 = 예상 행수.
    - 예: 총 1M행, NDV=100, `col=:x` → 선택도 1/100, 카디널리티 10,000.
- 💡 확장답안
    - 다중 컬럼 상관관계는 기본 통계로 오차 큼 → 확장 통계(extended stats)·히스토그램 필요.

---

### 36) 통계 부정확 시 현상/대응

- ✅ 모범답안
    - 현상: 잘못된 조인 순서/메소드, 인덱스·풀스캔 오판.
    - 대응: `dbms_stats` 갱신, 히스토그램, 동적 샘플링, 힌트/Plan Baseline.
- 💡 확장답안
    - `METHOD_OPT 'FOR COLUMNS SIZE SKEWONLY'`, `PUBLISH/NO_INVALIDATE` 등 옵션 활용.

---

### 37) 옵티마이저 모드

- ✅ 모범답안
    - 오답 C: RULE은 기본/권장 아님.
    - `ALL_ROWS`=처리량 최적화, `FIRST_ROWS(n)`=초기 응답 최적화.
- 💡 확장답안
    - 세션/문장 단위로 힌트 제어:
        
        SQL
        
        ```
        /*+ OPTIMIZER_FEATURES_ENABLE('19.1.0') FIRST_ROWS(10) */
        ```
        

---

## 부록. SQL 분석 도구

### 38) 실행계획 확인 3가지+

- ✅ 모범답안
    - `EXPLAIN PLAN`(추정), `AUTOTRACE`(실행+통계),
    - `DBMS_XPLAN.DISPLAY_CURSOR`(실제 실행 후),
    - 실시간 SQL 모니터링(장시간 SQL 추적).
- 💡 확장답안
    - 사용 예:
        
        SQL
        
        ```
        explain plan for <sql>;
        select * from table(dbms_xplan.display);
        
        select * from table(dbms_xplan.display_cursor(null, null, 'ALLSTATS LAST'));
        ```
        

---

### 39) Predicate Information 읽기

- ✅ 모범답안
    - ACCESS: 인덱스 접근 조건, FILTER: 스캔 후 거르는 조건.
- 💡 확장답안
    - 예: `ACCESS("T"."A"=:B1)` → 루트/브랜치 탐색 키,  
        `FILTER("T"."B">10)` → 리프 범위 내에서 추가 필터.

---

### 40) V$SQL로 문제 SQL 찾기

- ✅ 모범답안
    - `V$SQLAREA/STAT`로 상위 리소스 SQL 식별 → `SQL_ID`로 CHILD/PLAN 확인 → `DBMS_XPLAN`으로 실제 플랜·바인드 확인.
- 💡 확장답안
    - 예:
        
        SQL
        
        ```
        select sql_id, executions, buffer_gets, disk_reads
        from v$sqlarea
        order by buffer_gets desc
        fetch first 20 rows only;
        
        select * from table(dbms_xplan.display_cursor('&sql_id', null, 'ALLSTATS LAST +PEEKED_BINDS'));
        ```



### A1) 테이블은 어떻게 만들어요?

- 테이블은 `CREATE TABLE`로 만들고, 각 컬럼의 타입과 제약조건을 적어 줍니다. PK/UK, NOT NULL, CHECK, FK 같은 것들이에요. PK/UK를 만들면 그 키에 대한 인덱스는 자동으로 생깁니다. 자주 찾는 조건이나 정렬 컬럼은 인덱스를 따로 만들어 둡니다. 예: `CREATE TABLE t(id NUMBER PRIMARY KEY, name VARCHAR2(50) NOT NULL);`

### A2) 데이터는 어떤 방식으로 읽어요(스캔)?

- 테이블 풀스캔은 테이블을 처음부터 끝까지 쭉 읽는 방식이라 많이 건질 때 유리합니다.
- 인덱스 스캔은 인덱스에서 주소를 찾아 필요한 것만 찍어 읽는 방식이라 조금만 건질 때 유리합니다. 종류로는 레인지 스캔(맨앞 컬럼으로 범위를 훑음), 유니크 스캔(= 한 건), 전체/빠른 전체 스캔, 스킵 스캔, 내림차순 스캔이 있어요.

---

## 1장. SQL 처리 과정과 I/O

### 1) 구조적·집합적·선언적이 뭐예요?

- 구조적은 “테이블/열/관계”라는 정해진 틀에 맞춰 데이터를 다룬다는 뜻입니다.
- 집합적은 “행 하나하나를 절차적으로 처리”가 아니라 “조건을 만족하는 행들의 모음(집합)”을 한 번에 다룬다는 뜻입니다.
- 선언적은 “무엇을 원하는지”만 적고 “어떻게 실행할지”는 DB가(옵티마이저가) 알아서 고른다는 뜻입니다.

### 2) 파싱·최적화·실행은 뭐가 달라요?

- 파싱은 문법·의미를 검사하고, 대상 객체·권한을 확인하는 단계예요(여기서 커서를 만들죠).
- 최적화는 옵티마이저가 가능한 실행 방법들을 비교해서 제일 쓸만한 플랜을 고르는 단계예요(통계가 핵심).
- 실행은 그 플랜 순서대로 데이터를 실제로 읽고 조인하고 정렬하는 단계예요.

### 3) 옵티마이저는 무엇을 보고 비용을 계산해요?

- 테이블·인덱스 통계(행 개수, 서로 다른 값 수, 분포), I/O/CPU 비용 모델, 병렬도, 관련 파라미터를 보고 예상 비용을 냅니다.

### 4) “고객별 최근 10건”을 빠르게 읽으려면?

- 주문 날짜 내림차순에 맞춰 `(customer_id, order_date DESC)` 인덱스를 만들고, `ORDER BY order_date DESC FETCH FIRST 10`으로 가져옵니다. 이렇게 하면 정렬을 생략하고 인덱스만 타고 맨앞 10건만 읽게 됩니다.

### 5) “Cost가 낮으면 항상 빠르다”가 맞나요?

- 아니요. Cost는 추정치라 통계가 부정확하거나 캐시·스토리지 상태가 다르면 실제 시간과 어긋날 수 있어요.

### 6) 소프트 파싱과 하드 파싱은 뭐고, 하드 파싱은 어떻게 줄여요?

- 소프트 파싱은 기존 커서를 재사용하는 거고, 하드 파싱은 새 커서를 만들면서 최적화까지 다시 하는 거예요. 바인드 변수와 PreparedStatement를 쓰고 커서를 재사용하면 하드 파싱을 많이 줄일 수 있어요.

### 7) 논리 I/O·물리 I/O, 1블록·멀티블록, 쭉 읽기·여기저기 읽기?

- 논리 I/O는 버퍼 캐시에서 블록을 읽는 거고, 물리 I/O는 디스크에서 직접 끌어오는 거예요.
- 1블록 읽기는 보통 인덱스처럼 한 블록씩 톡톡 찍어 읽는 거고, 멀티블록 읽기는 여러 블록을 한 번에 묶어 읽는 거예요.
- 쭉 읽기는 연속 블록(풀스캔)이고, 여기저기 읽기는 불연속 블록(인덱스+ROWID)입니다.

### 8) 풀스캔이 좋을 때 vs 인덱스가 좋을 때?

- 조건에 맞는 행이 많고 전체적으로 훑는 게 싸면 풀스캔이 낫고, 조건에 맞는 행이 적고 정확히 찝어갈 수 있으면 인덱스가 낫습니다. 정렬 생략 가능 여부와 인덱스만 읽고 끝낼 수 있는지(커버링)도 같이 봅니다.

---

## 2장. 인덱스 기본

### 9) B+트리는 어떻게 찾아가요?

- 맨위(Root)에서 가지(Branch)를 따라 내려가며 길을 잡고, 맨아래(Leaf)에서 키와 ROWID를 확인합니다. 먼저 아래로 내려가고(수직), 같은 키 구간은 옆으로 이어서 읽어요(수평).

### 10) 언제 레인지 스캔이 안 되나요?

- 컬럼을 함수로 감싸서 원래 값 그대로 비교하지 않으면(예: `TO_CHAR(col)`) 보통 레인지 스캔이 안 됩니다. 이런 땐 함수 기반 인덱스를 쓰거나 비교식을 원형에 맞게 바꿔야 해요.

### 11) 인덱스로 ORDER BY를 없애려면?

- 정렬할 컬럼이 인덱스에서 맨앞부터 같은 방향으로 있어야 하고, WHERE로 범위를 어느 정도 좁혀야 합니다. 그래야 인덱스 순서 그대로 가져오면 끝나요.

### 12) Index Full Scan과 Index Fast Full Scan 차이는?

- Full Scan은 리프 순서를 그대로 따라가서 정렬 순서가 유지돼요. Fast Full은 순서를 무시하고 인덱스 전체를 빠르게 훑는데, 대신 정렬 보장은 없어요.

### 13) 맨앞 컬럼 조건이 없어도 인덱스를 쓸 수 있나요?

- 스킵 스캔을 쓰면 가능해요. 다만 맨앞 컬럼 값 종류가 적을수록 효과가 좋습니다.

---

## 3장. 인덱스 튜닝

### 14) 테이블 랜덤 읽기를 어떻게 줄이나요?

- 필요한 컬럼을 인덱스에 다 넣어서(커버링) 테이블까지 안 내려가게 하거나, 차라리 풀스캔이 더 싼 상황이면 풀스캔으로 돌리고, 파티션/데이터 군집을 개선해 점프 횟수를 줄입니다.

### 15) 인덱스 손익분기점은 어떻게 생각하면 되나요?

- 인덱스로 좁혀도 결국 테이블을 여기저기 많이 뛰어다녀야 하면 비용이 커집니다. 그 비용이 풀스캔(연속 읽기)보다 크다 싶으면 풀스캔이 이겨요.

### 16) “인덱스만 읽고 끝내기”는 어떻게 하나요?

- WHERE, SELECT, ORDER BY에 쓰는 컬럼을 인덱스에 다 넣어 두면 됩니다. 그러면 테이블로 내려갈 이유가 없어요.

### 17) “특정 계좌의 미결 최근 20건”은 어떻게?

- `(acct_id, status, tran_dt DESC)` 인덱스를 두고 `ORDER BY tran_dt DESC FETCH FIRST 20`으로 읽으면 정렬 없이 맨앞 20건만 뽑아 옵니다.

---

## 3.3 스캔 효율화

### 18) 액세스 조건과 필터 조건은 뭐가 달라요?

- 액세스 조건은 인덱스 안으로 들어갈 때 길잡이로 쓰는 조건이고, 필터 조건은 들어가서 읽은 것들 중에 추가로 거르는 조건입니다. 액세스 쪽이 많아질수록 훨씬 효율적이에요.

### 19) IN은 ‘=’이랑 같다고 보면 되나요?

- 거의 “여러 개의 =를 OR로 묶은 것”처럼 동작해요. 값이 너무 많으면 비효율이 생기거나 추정이 틀어질 수 있어요.

### 20) BETWEEN을 IN으로 바꾸면 항상 좋아요?

- 값이 딱딱 떨어지는 소수면 IN이 낫고, 범위가 넓거나 연속적이면 BETWEEN이 낫습니다.

### 21) LIKE는 언제 인덱스를 타요?

- 'ABC%'처럼 앞쪽이 고정이면 인덱스를 탈 수 있고, '%ABC'처럼 앞에 %가 있으면 보통 못 탑니다. 그런 건 텍스트 인덱스 같은 다른 방식을 써요.

---

## 4장. 조인 튜닝

### 22) NL, 소트 머지, 해시 조인의 느낌 차이?

- NL은 선행 결과를 한 줄씩 가져가며 후행을 인덱스로 찾아 붙이는 방식이라 선행이 적고 후행에 인덱스가 있을 때 빠릅니다.
- 소트 머지는 양쪽을 정렬해 나란히 합치는 방식이라 범위 조인이나 이미 정렬된 입력에 좋아요.
- 해시는 한쪽을 해시 테이블로 만들어 다른 쪽을 대조하는 방식이라 큰 데이터·낮은 선택도·병렬 처리에 유리합니다.

### 23) 고객→주문을 NL로 강제하려면?

- 조인 순서를 고객 먼저로 두고(`LEADING(customers)`), 주문 쪽은 `USE_NL(orders)`로 잡습니다. 주문 테이블에는 `customer_id` 인덱스가 있어야 해요.

### 24) 뷰 머징은 항상 되나요?

- 아니요. DISTINCT나 GROUP BY 같은 게 끼어 있으면 합치지 못할 때가 있어요. 필요하면 MERGE/NO_MERGE 힌트로 방향을 정합니다.

### 25) 언제 NL이 해시보다 빨라요?

- 선행 결과가 아주 작아지고(조건이 잘 먹혀서), 후행 테이블에 딱 맞는 인덱스가 있을 때입니다.

---

## 5장. 소트 튜닝

### 26) 소트는 메모리랑 TEMP를 어떻게 써요?

- 우선 메모리(PGA)에서 정렬하다가 부족하면 TEMP(디스크)로 흘려보내고, 다 모아서 합칩니다. TEMP로 넘어가면 보통 느려집니다.

### 27) 소트를 없애려면 어떻게 쓰면 돼요?

- WHERE로 값이 한 개로 딱 정해지면 GROUP BY/ORDER BY를 생략할 수 있고, 정렬이나 그룹이 필요하면 그 순서에 맞는 인덱스를 둬서 소트를 빼면 됩니다.

### 28) UNION과 UNION ALL은 뭐가 달라요?

- UNION은 중복을 없애려고 정렬/해시를 하니 느리고, UNION ALL은 그냥 붙이기만 해서 빠릅니다. 중복이 의미 없으면 ALL이 좋아요.

### 29) Top-N을 가볍게 가져오려면?

- 정렬 순서에 맞춘 인덱스를 두고 내림차순으로 바로 읽어 `FETCH FIRST N`만 가져오면 됩니다. 정렬을 생략하는 게 핵심이에요.

---

## 6장. DML 튜닝

### 30) Direct Path Insert는 뭐가 다른가요?

- 버퍼 캐시를 거치지 않고 위쪽 빈 공간(HWM 위)부터 연속으로 써서 빠릅니다. 대신 제약/트리거/인덱스/로깅 설정에 따른 비용은 신경 써야 해요.

### 31) 배치 처리(Array/JDBC)는 왜 빨라요?

- 여러 행을 묶어서 한 번에 보내니까 DB 호출 횟수가 확 줄어요. JDBC에선 `addBatch/executeBatch`를 씁니다.

### 32) 대량 DELETE는 어떻게 빨리 하나요?

- 파티션으로 나뉘어 있으면 해당 파티션을 DROP/TRUNCATE/EXCHANGE로 날려 버리는 게 제일 빠릅니다. 파티션 프루닝으로 대상 범위를 확 줄이는 것도 중요해요.

### 33) 락은 뭐가 있고, 읽기가 왜 안 막히죠?

- 대표적으로 행 락(TX), 테이블 락(TM), DDL 락이 있어요. 오라클은 MVCC라서 쓰기 중이어도 과거 버전을 읽어서 읽기가 막히지 않아요.

### 34) 시퀀스는 어떻게 해야 빨라요?

- CACHE를 켜면 메모리에 여러 값을 잡아놔서 빠르고, NOCACHE는 매번 디스크에 접근해 느립니다. RAC에서 ORDER 옵션은 순서를 지키지만 경합이 늘 수 있어요.

---

## 7장. SQL 옵티마이저

### 35) 선택도와 카디널리티는 뭐가 달라요?

- 선택도는 “조건에 맞는 비율”, 카디널리티는 “예상 행 수”예요. 예를 들어 서로 다른 값이 100개면 한 값의 선택도는 1/100이고, 전체가 1,000,000행이면 예상은 10,000행이에요.

### 36) 통계가 틀리면 무슨 일이 생겨요?

- 옵티마이저가 엉뚱한 조인 순서나 스캔 방식을 골라서 느려질 수 있어요. 통계를 갱신하고, 값 분포가 치우친 컬럼엔 히스토그램을 만들어 바로잡습니다.

### 37) 옵티마이저 모드는 어떻게 보나요?

- RULE은 이제 기본이 아니고, ALL_ROWS는 전체 처리량 위주, FIRST_ROWS(n)는 처음 몇 건 빨리 보내기 위주예요. 상황에 맞게 고르면 됩니다.

---

## 부록. SQL 분석 도구

### 38) 실행계획은 어떻게 확인해요?

- EXPLAIN PLAN은 “추정 플랜”, AUTOTRACE는 “실행+통계”, DBMS_XPLAN.DISPLAY_CURSOR는 “실제로 실행된 플랜”을 보여줘요. 오래 도는 건 실시간 모니터링으로 봅니다.

### 39) 실행계획에서 ACCESS와 FILTER는 뭔가요?

- ACCESS는 인덱스에 들어갈 때 쓴 조건이고, FILTER는 들어간 다음 추가로 걸러낸 조건이에요. ACCESS가 많을수록 스캔이 짧아집니다.

### 40) V$SQL로 문제 SQL은 어떻게 찾죠?

- V$SQLAREA/STAT에서 리소스를 많이 먹는 SQL을 먼저 고르고, 그 SQL_ID로 실제 플랜과 바인드 값을 DBMS_XPLAN으로 확인합니다. 거기서 튜닝 대상을 추립니다.