## 4장. 조인 튜닝

### 4.1 NL 조인

#### 4.1.1 기본 메커니즘

Nested Loop Join은 중첩 반복문과 같은 방식으로 동작한다.

text

```
for each row in 첫 번째 테이블(Driving Table) {
    for each matching row in 두 번째 테이블(Inner Table) {
        결과에 추가
    }
}
```

SQL

```
-- 주문과 고객 테이블 조인
SELECT o.주문번호, o.주문일자, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID
  AND o.주문일자 >= '2025-01-01';

처리 과정:
1. 주문 테이블에서 2025-01-01 이후 주문 검색
2. 각 주문에 대해 고객 테이블에서 해당 고객ID 검색
3. 결과 조합
```

#### 4.1.2 NL 조인 실행계획 제어

SQL

```
-- NL 조인 지정
SELECT /*+ USE_NL(o c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;

-- 조인 순서 지정
SELECT /*+ LEADING(o c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;
```

#### 4.1.3 NL 조인 수행 과정 분석

SQL

```
-- 주문(10만 건), 고객(1만 명)
SELECT /*+ USE_NL(o c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID
  AND o.주문일자 = '2025-01-01';

-- 주문일자 인덱스가 있다면
1. 주문 테이블에서 2025-01-01 주문 검색 (100건)
2. 각 주문마다 고객 테이블 조회 (100번)
3. 총 I/O: 주문 인덱스 + 주문 테이블(100건) + 고객 테이블(100건)
```

#### 4.1.4 NL 조인 튜닝 포인트

1. **드라이빙 테이블 선택**
    
    - 필터 조건으로 줄어드는 테이블을 드라이빙으로 선택
    - 작은 결과 집합을 먼저 접근
2. **인덱스 활용**
    
    - 드라이빙 테이블: 필터 조건에 맞는 인덱스
    - 이너 테이블: 조인 컬럼에 인덱스 필수

SQL

```
-- 최적화 전
SELECT o.주문번호, c.고객명
FROM 주문 o, 고객 c  
WHERE o.고객ID = c.고객ID
  AND c.지역 = '서울';
-- 인덱스: 주문(고객ID), 고객(PK:고객ID)

-- 최적화 후
SELECT /*+ LEADING(c o) USE_NL(o) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID  
  AND c.지역 = '서울';
-- 인덱스 추가: 고객(지역)
```

#### 4.1.5 NL 조인 특징 요약

**장점**

- 첫 번째 레코드를 빨리 출력
- 메모리 사용량 적음
- 조인 대상이 적을 때 유리
- 랜덤 액세스에 최적화된 환경에서 유리

**단점**

- 조인 대상이 많으면 비효율적
- 이너 테이블 인덱스 필수
- 랜덤 액세스가 많이 발생

#### 4.1.6 NL 조인 튜닝 실습

SQL

```
-- 문제 상황
SELECT /*+ LEADING(o c) USE_NL(c) */ o.주문번호, c.고객명, o.금액
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID
  AND o.주문일자 BETWEEN '2025-01-01' AND '2025-01-31';
-- 성능 저하: 주문일자 필터가 주문 테이블의 많은 행을 반환

-- 개선안 1: 드라이빙 테이블 변경
SELECT /*+ LEADING(c o) USE_NL(o) */ o.주문번호, c.고객명, o.금액
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID
  AND o.주문일자 BETWEEN '2025-01-01' AND '2025-01-31';

-- 개선안 2: 인덱스 추가
CREATE INDEX idx_order_date_cust ON 주문(주문일자, 고객ID);
```

#### 4.1.7 NL 조인 확장 메커니즘

**배치 NL 조인**

- 드라이빙 테이블에서 여러 행을 모아서 이너 테이블 액세스
- 이너 테이블 액세스 횟수 감소
- 인덱스 스캔 효율 증가

SQL

```
-- 일반 NL 조인
-- 100건이면 이너 테이블 100번 액세스

-- 배치 NL 조인 (100건을 10개씩 배치)
-- 이너 테이블 10번 액세스
SELECT /*+ USE_NL_WITH_INDEX(c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;
```

### 4.2 소트 머지 조인

#### 4.2.1 SGA vs. PGA

**SGA(System Global Area)**

- 인스턴스 공유 메모리
- 버퍼 캐시, 공유 풀, 라지 풀 등
- 모든 세션이 공유

**PGA(Program Global Area)**

- 세션별 전용 메모리
- 소트 영역, 해시 영역 등
- 세션마다 독립적

text

```
Oracle 메모리 구조
---------------------------
|           SGA          |
|  버퍼 캐시   |   공유 풀   |
---------------------------
|     PGA    |    PGA     |
|   (세션 1)  |  (세션 2)   |
---------------------------
```

#### 4.2.2 기본 메커니즘

소트 머지 조인의 처리 과정:

1. **소트 단계**
    
    - 양쪽 테이블을 조인 컬럼으로 정렬
    - PGA의 소트 영역 사용
    
2. **머지 단계**
    
    - 정렬된 두 데이터를 순차적으로 스캔하며 병합
    - 마치 두 개의 정렬된 배열을 병합하는 것과 유사

SQL

```
-- 소트 머지 조인 사용
SELECT /*+ USE_MERGE(o c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;

-- 처리 과정
1. 주문 테이블을 고객ID 기준으로 정렬
2. 고객 테이블을 고객ID 기준으로 정렬
3. 두 정렬된 집합을 병합하며 결과 생성
```

#### 4.2.3 소트 머지 조인이 빠른 이유

1. **Sequential I/O**
    
    - 정렬 후 순차적으로 읽기 때문에 효율적
    - 랜덤 I/O 부담 감소
2. **대용량 처리에 유리**
    
    - 많은 데이터를 조인할 때 효율적
    - NL 조인의 반복 액세스 부담 없음
3. **조인 컬럼 인덱스 불필요**
    
    - 이너 테이블에 인덱스가 없어도 가능
    - 양쪽 모두 Full Table Scan 가능

#### 4.2.4 소트 머지 조인의 주용도

1. **대용량 데이터 조인**
    
    - 배치 작업, 리포트 생성 등
    - 데이터 웨어하우스 환경
2. **조인 컬럼에 인덱스가 없는 경우**
    
    - 테이블 구조 변경이 어려운 환경
    - 임시 테이블 조인

SQL

```
-- 대용량 데이터 집계
SELECT /*+ USE_MERGE(s p) */ p.제품군, SUM(s.판매액)
FROM 판매내역 s, 제품 p
WHERE s.제품코드 = p.제품코드
  AND s.판매일자 BETWEEN '2025-01-01' AND '2025-12-31'
GROUP BY p.제품군;
```

#### 4.2.5 소트 머지 조인 제어하기

SQL

```
-- 조인 방식 지정
SELECT /*+ USE_MERGE(o c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;

-- 소트 생략 (인덱스가 이미 정렬되어 있을 때)
SELECT /*+ USE_MERGE(o c) NO_ORDER_BY(o) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;
-- 주문 테이블의 고객ID에 인덱스가 있으면 정렬 생략
```

#### 4.2.6 소트 머지 조인 특징 요약

**장점**

- 대용량 데이터 처리에 효율적
- 이너 테이블 인덱스 불필요
- 조인 결과가 많을 때 유리
- 스캔 효율성 높음

**단점**

- 소트 부하 발생
- PGA 메모리 사용량 많음
- 첫 번째 레코드 출력까지 시간 소요

### 4.3 해시 조인

#### 4.3.1 기본 메커니즘

해시 조인의 처리 과정:

1. **빌드 단계**
    
    - 작은 테이블(Build Input)로 해시 테이블 생성
    - PGA의 해시 영역 사용
2. **프로브 단계**
    
    - 큰 테이블(Probe Input)을 스캔하며 해시 테이블 검색
    - 해시 함수로 매칭 레코드 빠르게 찾음

SQL

```
-- 해시 조인 사용
SELECT /*+ USE_HASH(o c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;

-- 처리 과정
1. 고객 테이블(작은 쪽)로 해시 테이블 생성
2. 주문 테이블(큰 쪽) 스캔하며 해시 테이블에서 매칭
```

#### 4.3.2 해시 조인이 빠른 이유

1. **해시 탐색 효율성**
    
    - O(1) 시간 복잡도로 매칭 레코드 찾음
    - 인덱스 탐색보다 빠름
    
2. **메모리 내 처리**
    
    - 빌드 테이블이 메모리에 완전히 적재되면 매우 빠름
    - 디스크 I/O 최소화
    
3. **대용량 처리에 최적화**
    
    - NL 조인의 랜덤 액세스 부담 없음
    - 소트 머지 조인의 정렬 부담 없음
    

#### 4.3.3 대용량 Build Input 처리

빌드 테이블이 메모리에 안 들어가면 디스크 사용:

1. **메모리 내 해시 조인**
    
    - 빌드 테이블 전체가 메모리에 적재
    - 가장 빠른 처리 방식
    
2. **그레이스 해시 조인**
    
    - 메모리를 초과하면 파티션으로 나누어 처리
    - 디스크와 메모리를 함께 사용
    
3. **하이브리드 해시 조인**
    
    - 일부는 메모리에, 일부는 디스크에 저장
    - 메모리 사용 최적화
    

SQL

```
-- PGA 메모리 크기 조정
ALTER SESSION SET PGA_AGGREGATE_TARGET = 1G;
-- 충분한 메모리 할당으로 디스크 사용 최소화
```

#### 4.3.4 해시 조인 실행계획 제어

SQL

```
-- 해시 조인 지정
SELECT /*+ USE_HASH(o c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;

-- 빌드 테이블 지정
SELECT /*+ USE_HASH(o c) SWAP_JOIN_INPUTS(c) */ o.주문번호, c.고객명
FROM 주문 o, 고객 c
WHERE o.고객ID = c.고객ID;
-- 주문 테이블을 빌드 테이블로 사용
```

#### 4.3.5 조인 메소드 선택 기준

**NL 조인 선택 기준**

- 소량의 데이터 조인 (OLTP 환경)
- 이너 테이블에 좋은 인덱스 존재
- 조인 결과가 극히 일부일 때
- 첫 번째 레코드 빠른 출력이 중요할 때

**소트 머지 조인 선택 기준**

- 대용량 데이터 조인
- 조인 컬럼에 인덱스가 없을 때
- 조인 컬럼이 이미 정렬되어 있을 때
- 동등 조인이 아닌 경우(범위 조인)

**해시 조인 선택 기준**

- 대용량 데이터 조인
- 한쪽 테이블이 메모리에 적재 가능할 때
- 동등 조인만 가능
- 전체 처리 성능이 중요할 때

## 4.4 서브쿼리 조인

#### 4.4.1 서브쿼리 변환이 필요한 이유

옵티마이저는 서브쿼리를 조인으로 변환하여 최적화한다.

SQL

```
-- 중첩 서브쿼리 (비효율)
SELECT 주문번호, 금액
FROM 주문
WHERE 고객ID IN (
    SELECT 고객ID
    FROM 고객
    WHERE 지역 = '서울'
);

-- 조인으로 변환 (효율)
SELECT 주문번호, 금액
FROM 주문 o
JOIN 고객 c ON o.고객ID = c.고객ID
WHERE c.지역 = '서울';
```

#### 4.4.2 서브쿼리와 조인

**서브쿼리 종류**

1. **중첩 서브쿼리(Nested Subquery)**
    
    - WHERE 절에 사용
    - IN, EXISTS, 비교연산자 등과 함께 사용
    
2. **인라인 뷰(Inline View)**
    
    - FROM 절에 사용
    - 테이블처럼 취급
    
3. **스칼라 서브쿼리(Scalar Subquery)**
    
    - SELECT 절에 사용
    - 한 행, 한 컬럼 값 반환
    

SQL

```
-- 중첩 서브쿼리 (NL 조인으로 변환)
SELECT * FROM 주문
WHERE 고객ID IN (SELECT 고객ID FROM 고객 WHERE 지역 = '서울');

-- 인라인 뷰 (명시적 조인)
SELECT o.주문번호, c.고객명
FROM 주문 o
JOIN (SELECT 고객ID, 고객명 FROM 고객 WHERE 지역 = '서울') c
  ON o.고객ID = c.고객ID;
```

#### 4.4.3 뷰(View)와 조인

뷰는 저장된 SQL 쿼리다.

SQL

```
-- 뷰 생성
CREATE VIEW 서울고객 AS
SELECT 고객ID, 고객명, 전화번호
FROM 고객
WHERE 지역 = '서울';

-- 뷰 사용
SELECT o.주문번호, v.고객명
FROM 주문 o
JOIN 서울고객 v ON o.고객ID = v.고객ID;

-- 뷰 머징(View Merging)
-- 옵티마이저가 내부적으로 다음과 같이 변환
SELECT o.주문번호, c.고객명
FROM 주문 o
JOIN 고객 c ON o.고객ID = c.고객ID
WHERE c.지역 = '서울';
```

#### 4.4.4 스칼라 서브쿼리 조인

SQL

```
-- 스칼라 서브쿼리
SELECT o.주문번호, 
       (SELECT 고객명 FROM 고객 WHERE 고객ID = o.고객ID) AS 고객명
FROM 주문 o
WHERE o.주문일자 = '2025-01-01';

-- 내부적으로 조인으로 변환될 수 있음
SELECT o.주문번호, c.고객명
FROM 주문 o
LEFT JOIN 고객 c ON o.고객ID = c.고객ID
WHERE o.주문일자 = '2025-01-01';
```
