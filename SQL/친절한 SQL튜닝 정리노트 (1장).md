## 1장. SQL 처리 과정과 I/O

### 1.1 SQL 파싱과 최적화

#### 1.1.1 구조적, 집합적, 선언적 질의 언어

SQL은 세 가지 특징을 가진다:

**구조적(Structured)**

- 데이터가 테이블 구조로 저장되어 있다
- 행(Row)과 열(Column)로 구성된 2차원 구조다

**집합적(Set-based)**

- 한 번에 여러 건을 처리한다
- 절차적 언어처럼 한 건씩 처리하지 않는다

SQL

```
-- 절차적 사고: 고객을 한 명씩 확인해서 서울이면 출력
-- SQL 사고: 서울 고객 집합을 한 번에 가져와!
SELECT * FROM 고객 WHERE 지역 = '서울';
```

**선언적(Declarative)**

- "어떻게(How)"가 아닌 "무엇을(What)" 원하는지만 기술한다
- 실제 처리 방법은 DBMS가 결정한다

"원하는 결과집합을 구조적, 집합적으로 선언하지만, 그 결과 집합을 만드는 과정은 절차적일 수 밖에 없다. 즉, 프로시저가 필요한데, 그런 프로시저를 만들어 내는 DBMS 내부 엔진이 바로 SQL 옵티마이저다. 옵티마이저가 프로그래밍을 대신해 주는 셈이다."   - p.18
#### 1.1.2 SQL 최적화

SQL을 실행하기 전에 최적화 과정을 거친다. 이 과정은 크게 세 단계로 나뉜다.

1. **파싱(Parsing)**
    
    - 문법 검사: SQL 문법이 맞는지 확인
    - 의미 검사: 테이블과 컬럼이 실제로 존재하는지 확인
    - 권한 검사: 사용자가 해당 객체에 접근할 권한이 있는지 확인
    
2. **최적화(Optimization)**
    
    - 실행 계획 생성: 여러 가지 실행 방법을 만들어본다
    - 비용 계산: 각 방법의 예상 비용을 계산한다
    - 최적 계획 선택: 가장 비용이 적은 방법을 선택한다
    
3. **로우 소스 생성**
    
    - SQL 옵티마이저가 선택한 실행 계획대로 실행 가능한 코드 또는 프로시저 형태로 포맷팅한다
    

#### 1.1.3 SQL 옵티마이저

옵티마이저는 SQL의 실행 계획을 만드는 DBMS의 핵심 엔진이다.

**비용 기반 옵티마이저(CBO)**

- 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
- 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해
  각 실행계획의 예상비용을 산정한다.
- 최저 비용을 나타내는 실행계획을 선택한다.

SQL

```
-- 옵티마이저가 고민하는 상황
SELECT * FROM 주문 WHERE 주문일자 = '2025-08-01';

-- 고민 1: 인덱스를 쓸까? 풀 스캔을 할까?
-- 고민 2: 2025-08-01 주문이 전체의 0.1%면 인덱스 사용 (소)
-- 고민 3: 2025-08-01 주문이 전체의 50%면 풀 스캔 (대)
```

#### 1.1.4 실행계획과 비용

**실행계획** SQL을 어떻게 수행할지 단계별로 나타낸 것이다.

SQL

```
EXPLAIN PLAN FOR
SELECT e.이름, d.부서명
FROM 직원 e, 부서 d
WHERE e.부서코드 = d.부서코드
AND e.급여 > 5000;

-- 실행계획 예시
1. 직원 테이블에서 급여 > 5000인 직원 찾기 (인덱스 스캔)
2. 찾은 직원의 부서코드로 부서 테이블 조인 (Nested Loop)
3. 결과 반환
```

**비용(Cost)**: 어디까지나 예상치 (더 정확한 의미는 7장 1절 선행학습 추천)

- CPU 사용량, 디스크 I/O, 메모리 사용량 등을 종합한 예상 비용이다
- 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값
- 상대적인 값이며, 낮을수록 좋다
- 실제 수행 시간과 항상 일치하지는 않는다

#### 1.1.5 옵티마이저 힌트

옵티마이저가 잘못된 판단을 할 때 개발자가 직접 지시할 수 있다.

SQL

```
-- 인덱스 사용 강제
SELECT /*+ INDEX(e idx_emp_sal) */ *
FROM 직원 e
WHERE 급여 > 5000;

-- 조인 방법 지정
SELECT /*+ USE_NL(e d) */ *
FROM 직원 e, 부서 d
WHERE e.부서코드 = d.부서코드;

-- 테이블 액세스 방법 지정
SELECT /*+ FULL(e) */ *
FROM 직원 e;
```
# SQL 옵티마이저 힌트와 자바 애너테이션 비교

## 유사점 설명

SQL 옵티마이저 힌트와 자바 애너테이션은 둘 다 "코드에 지시사항을 추가하는 방식"이라는 점에서 유사하다:

Java

```
// 자바 애너테이션
@Override
public void method() { ... }

// SQL 힌트
SELECT /*+ INDEX(employees emp_idx) */ * FROM employees;
```

### 공통점:

1. **메타데이터 제공**: 둘 다 실행 엔진에 추가 정보를 제공한다
2. **원래 코드 변경 없이 동작 수정**: 기본 코드/쿼리 의미는 유지하면서 처리 방식만 변경한다
3. **특별한 구문으로 표시**: 일반 코드/쿼리와 구분되는 특별한 표기법을 사용한다

## "문법이 아니기 때문에 검증 불가" 하다(?)

 **SQL 힌트는 문법적으로만 검사되고 의미적 유효성은 실행 시점에만 확인된다**는 의미다.

예시로 비교해보면 일단

### 1.  자바 애너테이션의 검증

Java

```
@Table(name = "employees")  // 컴파일 시점에 검증됨
class Employee { ... }

@Column(name = "nonexistent_column")  // 타입 체크로 검증 가능
private String name;
```

- 컴파일러가 애너테이션 속성이 올바른지 검사한다
- 틀린 속성명이나 타입은 컴파일 오류가 발생한다

### 2. SQL 힌트의 검증

SQL

```
SELECT /*+ INDEX(employees emp_idx) */ * FROM employees;
```

- 문법상 힌트 형식은 맞지만 **실제 emp_idx 인덱스가 존재하는지**는 실행 전까지 확인할 수 없다
- 인덱스가 없어도 문법 오류가 아니라 **그냥 힌트를 무시**하고 실행된다

SQL

```
-- 존재하지 않는 인덱스를 지정해도 문법 오류 없음
SELECT /*+ INDEX(employees nonexistent_idx) */ * FROM employees;
```

## 실제 차이점 예시

### 자바 애너테이션:

Java

```
@SuppressWarnings("unchecked")  // 컴파일러가 이 속성 검증함
public List<String> getNames() { ... }

@SuppressWarnings("invalid_option")  // 컴파일 오류 발생!
public void process() { ... }
```

### SQL 힌트:

SQL

```
-- 문법은 맞지만 실제 없는 인덱스라도 오류 없이 힌트만 무시됨
SELECT /*+ INDEX(employees idx_salary) */ 
FROM employees 
WHERE salary > 5000;
```

SQL 힌트는 "제안"일 뿐 강제가 아니며, 힌트가 유효하지 않더라도 SQL은 실행된다. 이것이 "문법이 아니기 때문에 검증 불가"라는 의미다.
# 추가 설명 옵티마이저의 실행계획 선택 과정

아래 그림으로 데이터베이스 옵티마이저가 어떻게 실행계획을 선택하는지 알 수 있다:

text

```
┌───────────────────────────────────────────────────────────┐
│                      SQL 쿼리 입력                          │
└───────────────────────────┬───────────────────────────────┘
                            ▼
┌───────────────────────────────────────────────────────────┐
│                      쿼리 파싱 및 분석                        │
└───────────────────────────┬───────────────────────────────┘
                            ▼
┌───────────────────────────────────────────────────────────┐
│                       통계 정보 수집                         │
├───────────────────────────────────────────────────────────┤
│          • 테이블 크기 (행 수)    • 컬럼 값 분포                 │
│          • 인덱스 유무와 종류     • 히스토그램 정보                │
│          • 테이블 블록 수        • 조건절 선택도                 │
└───────────────────────────┬───────────────────────────────┘
                            ▼
┌───────────────────────────────────────────────────────────┐
│                  가능한 실행계획 후보 생성                      │
├───────────────────────────────────────────────────────────┤
│          계획 A: 테이블 풀스캔    계획 B: 인덱스 스캔             │
│          계획 C: 해시 조인       계획 D: 중첩 루프 조인           │
└───────────────────────────┬───────────────────────────────┘
                            ▼
┌───────────────────────────────────────────────────────────┐
│                   각 실행계획의 비용 계산                       │
├───────────────────────────────────────────────────────────┤
│            비용 = CPU 비용 + (I/O 비용 × 가중치)               │
│                                                           │
│          계획 A: 비용 150        계획 B: 비용 80               │
│          계획 C: 비용 120        계획 D: 비용 60               │
└───────────────────────────┬───────────────────────────────┘
                            ▼
┌───────────────────────────────────────────────────────────┐
│                가장 낮은 비용의 실행계획 선택                    │
│                     (예: 계획 D 선택)                        │
└───────────────────────────┬───────────────────────────────┘
                            ▼
┌───────────────────────────────────────────────────────────┐
│                     최종 실행계획 생성                        │
└───────────────────────────────────────────────────────────┘
```

## 옵티마이저의 선택 근거 설명

1. **통계 정보 기반**:
    
    - 테이블의 크기 (행 수가 많으면 인덱스 선호)
    - 조건절의 선택도 (조건이 10%이하 행만 필터링하면 인덱스 유리)
    - 인덱스 특성 (고유성, 클러스터링 여부)
    
2. **조인 방식 선택**:
    
    - 작은 테이블 + 큰 테이블 → 중첩 루프 조인 선호
    - 두 큰 테이블 → 해시 조인 선호
    - 정렬된 데이터 → 병합 조인 선호
    
3. **비용 계산 요소**:
    
    - 디스크 I/O (가장 비중 높음)
    - CPU 사용량
    - 메모리 사용량
    - 네트워크 전송량
    
4. **데이터 분포와 상관관계**:
    
    - 데이터 편향성 (skewness)
    - 컬럼 간 상관관계
    
5. **힌트와 환경 설정**:
    
    - 개발자가 제공한 힌트
    - 시스템 파라미터 설정
    

옵티마이저는 이러한 요소들을 종합적으로 고려해 수학적 모델에 따라 가장 효율적이라고 예측되는 
실행계획을 선택한다
### 1.2 SQL 공유 및 재사용

#### 1.2.1 소프트 파싱 vs. 하드 파싱

**하드 파싱**

- SQL을 처음 실행할 때 발생한다
- 파싱, 최적화, 실행계획 생성의 전 과정을 수행한다
- CPU를 많이 사용하고 시간이 오래 걸린다

**소프트 파싱**

- 이전에 실행한 SQL의 실행계획을 재사용한다
- Library Cache에서 동일한 SQL을 찾는다
- 찾으면 바로 실행 단계로 넘어간다

SQL

```
-- 첫 번째 실행: 하드 파싱
SELECT * FROM 고객 WHERE 고객ID = 100;

-- 두 번째 실행: 소프트 파싱 (동일한 SQL)
SELECT * FROM 고객 WHERE 고객ID = 100;

-- 세 번째 실행: 하드 파싱 (다른 SQL로 인식)
SELECT * FROM 고객 WHERE 고객ID = 200;
```

#### 1.2.2 바인드 변수의 중요성

바인드 변수를 사용하면 SQL을 재사용할 수 있다.

**리터럴 SQL의 문제점**

SQL

```
-- 각각 다른 SQL로 인식되어 매번 하드 파싱
SELECT * FROM 주문 WHERE 주문번호 = 1001;
SELECT * FROM 주문 WHERE 주문번호 = 1002;
SELECT * FROM 주문 WHERE 주문번호 = 1003;
-- ... 수천 개의 서로 다른 SQL이 생성됨
```

**바인드 변수 사용**

SQL

```
-- 하나의 SQL로 인식되어 재사용 가능
SELECT * FROM 주문 WHERE 주문번호 = :order_no;

-- Java 예시
PreparedStatement pstmt = conn.prepareStatement(
    "SELECT * FROM 주문 WHERE 주문번호 = ?"
);
pstmt.setInt(1, 1001);  // 바인드 변수에 값 설정
```

### 1.3 데이터 저장 구조 및 I/O 메커니즘

#### 1.3.1 SQL이 느린 이유

SQL이 느린 가장 큰 이유는 디스크 I/O다.

**속도 차이**

- CPU 캐시: 1나노초
- 메모리: 100나노초
- SSD: 100마이크로초
- HDD: 10밀리초

디스크는 메모리보다 10만 배 이상 느리다!

#### 1.3.2 데이터베이스 저장 구조

**세그먼트(Segment)**

- 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트
- 테이블, 인덱스를 생성할 때 데이터를 어떤 테이블스페이스에
  저장할지를 지정
- 여러 익스텐트로 구성
- 파티션 구조가 아니라면 테이블도 하나의 세그먼트,
  인덱스도 하나의 세그먼트다.
- 파티션 구조라면, 각 파티션이 하나의 세그먼트
- LOB 컬럼은 그 자체가 하나의 세그먼트를 구성, 자신이 속한
  테이블과 다른 별도 공간에 값을 저장한다.

**익스텐트(Extent)**

- 연속된 블록의 집합
- 공간을 확장하는 단위
- 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면
  해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가 할당

**블록(Block)**

- 데이터베이스 I/O의 최소 단위
- 데이터를 읽고 쓰는 단위
- 한 블록은 하나의 테이블이 독점. 즉, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드
- 한 익스텐트도 하나의 테이블이 독점. 즉, 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록.
- 보통 8KB 크기

text

```
세그먼트 (테이블)
  └─ 익스텐트 1 (64KB = 8블록)
       ├─ 블록 1 (8KB) - 행 1~10
       ├─ 블록 2 (8KB) - 행 11~20
       └─ ...
  └─ 익스텐트 2
       └─ ...
```

테이블스페이스, 세그먼트, 익스텐트, 블록 간 관계뿐만 아니라, 이들과 데이터파일 간의 관계도 알아둘 필요가 있다.

세그먼트 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받는다고 했는데, 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있다. 아니, 서로 다른 데이터파일에 위치할 가능성이 더 높다. 
하나의 테이블스페이스를 여러 데이터파일로 구성하면, 파일 경합을 줄이기 위해 DBMS 가 데이터를 가능한 한 여러 데이터파일로 분산해서 저장하기 때문이다.
#### 1.3.3 블록 단위 I/O

데이터베이스는 블록 단위로 I/O를 수행한다.

SQL

```
-- 한 행만 필요해도 블록 전체를 읽는다
SELECT 이름 FROM 직원 WHERE 직원ID = 100;

-- 직원ID 100이 블록 5에 있다면:
-- 1. 블록 5 전체(8KB)를 메모리로 읽기
-- 2. 블록 5에서 직원ID 100인 행 찾기
-- 3. 이름 컬럼 값 반환
```

#### 1.3.4 시퀀셜 액세스 vs. 랜덤 액세스

**시퀀셜 액세스**

- 논리적/물리적으로 연속된 블록을 읽는다
- 한 번의 I/O로 여러 블록을 읽을 수 있다
- Multi Block I/O가 가능하다

**랜덤 액세스**

- 떨어져 있는 블록을 읽는다
- 한 번에 한 블록씩만 읽는다
- Single Block I/O만 가능하다

SQL

```
-- 시퀀셜 액세스 (Table Full Scan)
SELECT * FROM 직원;  -- 모든 블록을 순서대로 읽기

-- 랜덤 액세스 (Index를 통한 액세스)
SELECT * FROM 직원 WHERE 직원ID = 100;  -- 특정 블록만 읽기
```

#### 1.3.5 논리적 I/O vs. 물리적 I/O

**논리적 I/O**

- 메모리(버퍼 캐시)에서 블록을 읽는 것
- 빠르다 (마이크로초 단위)

**물리적 I/O**

- 디스크에서 블록을 읽는 것
- 느리다 (밀리초 단위)

text

```
사용자 SQL 요청
    ↓
버퍼 캐시 확인
    ↓
있으면: 논리적 I/O (빠름)
없으면: 물리적 I/O (느림) → 버퍼 캐시에 적재
    ↓
결과 반환
```

**버퍼 캐시 히트율**

text

```
히트율 = (논리적 I/O - 물리적 I/O) / 논리적 I/O × 100

예: 논리적 I/O 1000번, 물리적 I/O 50번
히트율 = (1000 - 50) / 1000 × 100 = 95%
```

#### 1.3.6 Single Block I/O vs. Multiblock I/O

**Single Block I/O**

- 한 번에 한 블록씩 읽는다
- 인덱스를 통한 테이블 액세스 시 사용
- 랜덤 액세스에서 발생

**Multiblock I/O**

- 한 번에 여러 블록을 읽는다
- 테이블 풀 스캔 시 사용
- 시퀀셜 액세스에서 발생
- db_file_multiblock_read_count 파라미터로 조정

SQL

```
-- Single Block I/O
SELECT * FROM 직원 WHERE 직원ID = 100;
-- 인덱스 → 테이블: 블록을 하나씩 읽음

-- Multiblock I/O  
SELECT AVG(급여) FROM 직원;
-- 전체 테이블 스캔: 여러 블록을 한 번에 읽음
```

#### 1.3.7 Table Full Scan vs. Index Range Scan

**Table Full Scan**

- 테이블의 모든 블록을 읽는다
- Multiblock I/O를 사용한다
- 많은 데이터를 읽을 때 유리하다

**Index Range Scan**

- 인덱스를 통해 필요한 부분만 읽는다
- Single Block I/O를 사용한다
- 적은 데이터를 읽을 때 유리하다

SQL

```
-- Table Full Scan이 유리한 경우
SELECT * FROM 주문 WHERE 주문일자 >= '2025-08-01';
-- 전체 데이터의 20% 이상이면 풀 스캔이 빠를 수 있다

-- Index Range Scan이 유리한 경우
SELECT * FROM 주문 WHERE 주문번호 = 12345;
-- 한 건만 읽으므로 인덱스가 훨씬 빠르다
```

#### 1.3.8 캐시 탐색 메커니즘

버퍼 캐시에서 블록을 찾는 과정이다.

**해시 체인 구조**

text

```
해시 함수(블록 주소) → 해시 버킷
                      ↓
                    체인 탐색
                      ↓
                    블록 발견
```

**LRU(Least Recently Used) 알고리즘**

- 가장 오래 사용하지 않은 블록을 제거한다
- Hot 영역: 자주 사용하는 블록
- Cold 영역: 자주 사용하지 않는 블록

