## 3장. 인덱스 튜닝

### 3.1 테이블 액세스 최소화

#### 3.1.1 테이블 랜덤 액세스

인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스다.

SQL

```
-- 인덱스: 부서코드
SELECT * FROM 직원 WHERE 부서코드 = 'A001';

처리 과정:
1. 부서코드 인덱스에서 'A001' 찾기
2. 각 ROWID로 테이블 랜덤 액세스
3. 100명이면 최대 100번의 랜덤 액세스 발생
```

**랜덤 액세스의 부담**

- Single Block I/O
- 블록마다 다른 위치
- 버퍼 캐시 히트율이 낮으면 매우 느림

#### 3.1.2 인덱스 클러스터링 팩터

클러스터링 팩터는 인덱스 정렬 순서와 테이블 정렬 순서의 일치도다.

text

```
좋은 클러스터링 팩터:
인덱스: 1, 2, 3, 4, 5
테이블: 1, 2, 3, 4, 5 (같은 블록에 모여있음)

나쁜 클러스터링 팩터:
인덱스: 1, 2, 3, 4, 5  
테이블: 3, 1, 5, 2, 4 (여러 블록에 흩어져있음)
```
#### 3.1.3 인덱스 손익분기점

인덱스를 사용하는 것이 Full Table Scan보다 느려지는 지점이다.

SQL

```
-- 전체 데이터의 5~10% 이상 읽으면 Full Scan이 유리할 수 있다
SELECT * FROM 주문 WHERE 주문상태 = '완료';
-- '완료'가 전체의 90%라면 인덱스가 오히려 느리다

-- 손익분기점 계산 요소
1. 클러스터링 팩터
2. 버퍼 캐시 히트율  
3. 테이블 크기
4. 선택도(Selectivity)
```

#### 3.1.4 인덱스 컬럼 추가

테이블 액세스를 줄이기 위해 인덱스에 컬럼을 추가한다.

SQL

```
-- 기존 인덱스: (부서코드)
SELECT 부서코드, 이름, 급여 
FROM 직원 
WHERE 부서코드 = 'A001' AND 급여 >= 5000;

-- 개선: 인덱스 (부서코드, 급여)
-- 급여 조건을 인덱스에서 필터링하여 테이블 액세스 감소

-- 더 개선: 인덱스 (부서코드, 급여, 이름)  
-- 테이블 액세스 없이 인덱스만으로 처리 (Covered Index)
```

#### 3.1.5 인덱스만 읽고 처리

Covered Index 또는 Covering Index라고 한다.

SQL

```
-- 인덱스: (고객ID, 주문일자, 주문금액)
SELECT 고객ID, SUM(주문금액)
FROM 주문
WHERE 주문일자 BETWEEN '2025-08-01' AND '2025-08-31'
GROUP BY 고객ID;

-- 테이블 액세스 없이 인덱스만으로 처리 가능
```

#### 3.1.6 인덱스 구조 테이블

IOT(Index-Organized Table)는 테이블을 인덱스 구조로 저장한다.

SQL

```
-- IOT 생성
CREATE TABLE 거래내역 (
    거래일자 DATE,
    계좌번호 VARCHAR2(20),
    거래금액 NUMBER,
    CONSTRAINT pk_거래 PRIMARY KEY (거래일자, 계좌번호)
) ORGANIZATION INDEX;

-- 장점: 
-- 1. PK 순서로 정렬 저장
-- 2. 테이블 랜덤 액세스 없음
-- 3. PK 기반 조회가 빠름

-- 단점:
-- 1. PK가 아닌 검색은 느림
-- 2. DML 성능 저하 가능
```

#### 3.1.7 클러스터 테이블

관련 데이터를 같은 블록에 모아서 저장한다.

SQL

```
-- 클러스터 생성
CREATE CLUSTER 부서_직원_클러스터 (부서코드 VARCHAR2(10));

-- 클러스터 테이블 생성
CREATE TABLE 부서 (
    부서코드 VARCHAR2(10),
    부서명 VARCHAR2(50)
) CLUSTER 부서_직원_클러스터(부서코드);

CREATE TABLE 직원 (
    직원ID NUMBER,
    부서코드 VARCHAR2(10),
    이름 VARCHAR2(50)
) CLUSTER 부서_직원_클러스터(부서코드);

-- 같은 부서코드의 부서와 직원 정보가 같은 블록에 저장됨
```

### 3.2 부분범위 처리 활용

#### 3.2.1 부분범위 처리

전체 결과를 다 만들지 않고 일부만 만들어 바로 전송한다.

SQL

```
-- 전체범위 처리 (모든 정렬 완료 후 출력)
SELECT * FROM 직원 ORDER BY 입사일자;

-- 부분범위 처리 (인덱스 이용)
SELECT * FROM 직원 WHERE ROWNUM <= 10 ORDER BY 입사일자;
-- 입사일자 인덱스가 있다면 10건만 읽고 멈춤
```

#### 3.2.2 부분범위 처리 구현

**ROWNUM 사용**

SQL

```
-- 상위 10건만 조회
SELECT * FROM (
    SELECT * FROM 직원 ORDER BY 급여 DESC
) WHERE ROWNUM <= 10;
```

**ROW_NUMBER() 분석함수**

SQL

```
SELECT * FROM (
    SELECT *, ROW_NUMBER() OVER (ORDER BY 급여 DESC) AS rn
    FROM 직원
) WHERE rn BETWEEN 11 AND 20;  -- 11~20번째
```

**FETCH FIRST (12c 이상)**

SQL

```
SELECT * FROM 직원
ORDER BY 급여 DESC
FETCH FIRST 10 ROWS ONLY;
```

#### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

OLTP는 소량 데이터를 빠르게 처리해야 한다.

SQL

```
-- 온라인 쇼핑몰 상품 검색
SELECT * FROM 상품
WHERE 카테고리 = '전자제품' 
  AND 가격 BETWEEN 100000 AND 500000
ORDER BY 인기도 DESC
FETCH FIRST 20 ROWS ONLY;

-- 인덱스: (카테고리, 인기도 DESC, 가격)
-- 부분범위 처리로 빠른 응답 가능
```

### 3.3 인덱스 스캔 효율화

#### 3.3.1 인덱스 탐색

인덱스 탐색 효율은 스캔 범위와 직결된다.

SQL

```
-- 인덱스: (지역, 연령, 가입일)

-- 좋음: 선두 컬럼 사용
WHERE 지역 = '서울' AND 연령 = 30

-- 나쁨: 선두 컬럼 미사용  
WHERE 연령 = 30 AND 가입일 = '2025-08-01'
```

#### 3.3.2 인덱스 스캔 효율성

스캔 효율성 = 유효 인덱스 레코드 / 스캔한 인덱스 레코드

SQL

```
-- 인덱스: (부서, 입사일)
SELECT * FROM 직원
WHERE 부서 = 'A001' 
  AND 입사일 >= '2025-08-01';

-- A001 부서의 모든 직원을 스캔하며 입사일 체크
-- 2024년 이전 입사자가 많으면 비효율적
```

#### 3.3.3 액세스 조건과 필터 조건

**액세스 조건**: 인덱스 스캔 범위를 결정 **필터 조건**: 인덱스에서 추가로 체크

SQL

```
-- 인덱스: (부서코드, 직급)
SELECT * FROM 직원
WHERE 부서코드 = 'A001'    -- 액세스 조건
  AND 직급 = '과장'         -- 액세스 조건
  AND 급여 >= 5000;        -- 필터 조건 (테이블에서 체크)

-- 인덱스: (부서코드, 급여, 직급)으로 변경하면
WHERE 부서코드 = 'A001'    -- 액세스 조건
  AND 급여 >= 5000         -- 액세스 조건
  AND 직급 = '과장';       -- 필터 조건 (인덱스에서 체크)
```

#### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

SQL

```
-- 인덱스: (부서, 급여)

-- Case 1: 높은 군집성
WHERE 부서 = 'A001' AND 급여 >= 5000
-- A001 부서의 5000 이상만 연속으로 스캔

-- Case 2: 낮은 군집성  
WHERE 부서 LIKE 'A%' AND 급여 = 5000
-- 모든 A로 시작하는 부서를 스캔하며 급여 5000 찾기
```

#### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

SQL

```
-- 인덱스: (입사일, 부서)
SELECT * FROM 직원
WHERE 입사일 >= '2025-08-01'
  AND 부서 = 'A001';

-- 2025-01-01 이후 모든 직원을 스캔하며 A001 찾기
-- 매우 비효율적!

-- 개선: 인덱스를 (부서, 입사일)로 변경
```

#### 3.3.6 BETWEEN을 IN-List로 전환

SQL

```
-- 원본 (비효율적)
-- 인덱스: (지점, 일자, 상품)
SELECT * FROM 매출
WHERE 지점 = '강남'
  AND 일자 BETWEEN '2025-08-01' AND '2025-08-31'
  AND 상품 = 'P001';

-- 개선 (IN-List 전환)
SELECT * FROM 매출  
WHERE 지점 = '강남'
  AND 일자 IN ('2025-08-01', '2025-08-02', ..., '2024-01-31')
  AND 상품 = 'P001';

-- 각 일자별로 상품 P001만 정확히 액세스
```

#### 3.3.7 Index Skip Scan 활용

SQL

```
-- 인덱스: (성별, 지역, 연령)
-- 성별은 M/F 두 개 값만 존재

-- 일반 스캔 (비효율)
SELECT * FROM 고객 WHERE 지역 = '서울';

-- Skip Scan 힌트 사용
SELECT /*+ INDEX_SS(고객 idx_고객) */ *
FROM 고객 WHERE 지역 = '서울';

-- 내부적으로 처리
WHERE 성별='M' AND 지역='서울'
UNION ALL  
WHERE 성별='F' AND 지역='서울'
```

#### 3.3.8 IN 조건은 '='인가

IN 조건은 여러 개의 '=' 조건이다.

SQL

```
-- 인덱스: (부서, 직급)
SELECT * FROM 직원
WHERE 부서 IN ('A001', 'B001')
  AND 직급 = '과장';

-- 내부적으로 처리
WHERE (부서='A001' AND 직급='과장')
   OR (부서='B001' AND 직급='과장')

-- 각 부서별로 과장만 효율적으로 액세스
```

#### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

SQL

```
-- BETWEEN (범위가 명확)
WHERE 고객명 BETWEEN '가' AND '나'
-- '가'로 시작 ~ '나'로 시작하는 모든 값

-- LIKE (범위가 명확)  
WHERE 고객명 LIKE '김%'
-- '김'으로 시작하는 값만

-- 주의: LIKE는 와일드카드 위치가 중요
WHERE 고객명 LIKE '%김%'  -- 인덱스 사용 불가
```

#### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

SQL

```
-- 인덱스: (카테고리, 가격, 브랜드)

-- 비효율적
WHERE 카테고리 = '전자제품'
  AND 가격 BETWEEN 100000 AND 9999999  -- 사실상 모든 가격
  AND 브랜드 = '삼성';

-- 효율적 (불필요한 범위 조건 제거)
WHERE 카테고리 = '전자제품'
  AND 브랜드 = '삼성';
-- 인덱스를 (카테고리, 브랜드, 가격)으로 재구성 고려
```

#### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

**동적 SQL**

SQL

```
-- 조건에 따라 SQL을 다르게 생성
IF :부서 IS NOT NULL AND :직급 IS NOT NULL THEN
    SELECT * FROM 직원 WHERE 부서 = :부서 AND 직급 = :직급;
ELSIF :부서 IS NOT NULL THEN
    SELECT * FROM 직원 WHERE 부서 = :부서;
END IF;

-- 장점: 각 경우에 최적화된 실행계획
-- 단점: 코드 복잡, 하드파싱 증가
```

**정적 SQL with NVL**

SQL

```
SELECT * FROM 직원
WHERE 부서 = NVL(:부서, 부서)
  AND 직급 = NVL(:직급, 직급);

-- 장점: 코드 간단
-- 단점: 인덱스 사용 불가능한 경우 발생
```

#### 3.3.12 함수호출부하 해소를 위한 인덱스 구성

SQL

```
-- 함수 호출이 많은 경우
SELECT * FROM 주문
WHERE TO_CHAR(주문일시, 'YYYYMMDD') = '20250801'
  AND 고객ID = :cust_id;

-- 함수 기반 인덱스 생성
CREATE INDEX idx_order_date ON 주문(TO_CHAR(주문일시, 'YYYYMMDD'), 고객ID);

-- 또는 컬럼 추가 고려
ALTER TABLE 주문 ADD 주문일자 AS (TO_CHAR(주문일시, 'YYYYMMDD'));
CREATE INDEX idx_order_date2 ON 주문(주문일
```

### 3.4 인덱스 설계

#### 3.4.1 인덱스 설계가 어려운 이유

인덱스 설계는 다양한 요소를 고려해야 한다:

- 다양한 조건과 정렬 요구사항
- 테이블 특성(크기, 업데이트 빈도)
- 트랜잭션 패턴
- 인덱스 유지관리 부담
- 서로 상충되는 요구사항

#### 3.4.2 가장 중요한 두 가지 선택 기준

1. **조건절 컬럼**
    
    - WHERE 절에 사용되는 컬럼
    - 자주 사용되는 필터 조건
2. **선택도(Selectivity)**
    
    - 선택도 = 유니크한 값의 수 / 전체 행 수
    - 높을수록 인덱스 효율 증가

SQL

```
-- 고객ID: 선택도 높음 (100만 고객 중 각자 다른 ID)
-- 성별: 선택도 낮음 (M/F 두 가지 값만 존재)

-- 좋은 인덱스 구성
CREATE INDEX idx_cust ON 고객(고객ID, 가입일);  -- 선택도 높은 컬럼 먼저

-- 나쁜 인덱스 구성
CREATE INDEX idx_gender ON 고객(성별);  -- 선택도 낮은 컬럼만으로 구성
```

#### 3.4.3 스캔 효율성 이외의 판단 기준

1. **DML 부하**
    
    - 인덱스가 많을수록 INSERT/UPDATE/DELETE 성능 저하
    - 갱신이 많은 테이블은 인덱스 최소화
2. **저장 공간**
    
    - 인덱스도 디스크 공간을 차지
    - 대용량 테이블의 경우 인덱스 크기도 상당함
3. **인덱스 경합**
    
    - 동시 DML이 많은 경우 인덱스 경합 발생
    - 불필요한 인덱스는 제거 필요

#### 3.4.4 공식을 초월한 전략적 설계

**전체 시스템 관점**

- 가장 중요한 쿼리에 최적화
- 자원 사용량이 많은 쿼리 우선 처리
- 사용자 체감 성능 중심

**예시: 전자상거래 시스템**

text

```
1. 상품 검색 (가장 빈번): 카테고리, 가격 인덱스 최적화
2. 주문 조회 (중요): 고객ID, 주문일자 인덱스 최적화
3. 리포트 쿼리 (백그라운드): 자원 사용 제한
```

#### 3.4.5 소트 연산을 생략하기 위한 컬럼 추가

SQL

```
-- 빈번한 쿼리
SELECT * FROM 주문
WHERE 고객ID = :id
ORDER BY 주문일자 DESC;

-- 최적 인덱스
CREATE INDEX idx_order ON 주문(고객ID, 주문일자 DESC);
-- 정렬 연산 생략 가능
```

#### 3.4.6 결합 인덱스 선택도

결합 컬럼의 선택도는 개별 컬럼보다 높다.

SQL

```
-- 개별 선택도
성별: 2가지 값 ÷ 100만 행 = 0.000002
연령대: 10가지 값 ÷ 100만 행 = 0.00001

-- 결합 선택도
(성별, 연령대): 20가지 조합 ÷ 100만 행 = 0.00002

-- 결합 인덱스
CREATE INDEX idx_demo ON 고객(성별, 연령대);
SELECT * FROM 고객 WHERE 성별 = 'M' AND 연령대 = '30대';
```

#### 3.4.7 중복 인덱스 제거

SQL

```
-- 중복 인덱스
CREATE INDEX idx_emp1 ON 직원(부서코드);
CREATE INDEX idx_emp2 ON 직원(부서코드, 직급);  -- 첫 번째 포함
CREATE INDEX idx_emp3 ON 직원(부서코드, 입사일);  -- 첫 번째 포함

-- 해결책: 첫 번째 인덱스 삭제 (두 번째와 세 번째가 있으면 필요없음)
DROP INDEX idx_emp1;
```

#### 3.4.8 인덱스 설계도 작성

대규모 시스템에서는 인덱스 설계도를 작성하는 것이 좋다.

text

```
테이블: 주문
--------------------------------------
컬럼           | 데이터 타입  | 설명
--------------------------------------
주문ID        | NUMBER      | PK
고객ID        | NUMBER      | FK
주문일시       | DATE        | 
상품ID        | NUMBER      | FK
수량          | NUMBER      |
금액          | NUMBER      |
--------------------------------------

인덱스 목록:
1. PK_주문(주문ID) - PK
2. IDX_주문_고객(고객ID, 주문일시 DESC) - 고객별 주문 조회
3. IDX_주문_상품(상품ID, 주문일시) - 상품별 판매 이력
4. IDX_주문_일자(TO_CHAR(주문일시,'YYYYMM'), 금액) - 월별 리포트
```