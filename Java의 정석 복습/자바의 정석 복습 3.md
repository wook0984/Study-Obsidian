# 자바의 정석 복습 -컬렉션 프레임 워크 정리

---

## **1. 컬렉션 프레임워크(Collections Framework)**

- 표준화된 자료구조·알고리즘 모음을 제공하는 라이브러리이다
- 공통 인터페이스를 기준으로 다양한 구현체를 교체해 사용할 수 있다(유연성, 재사용성 향상)
- 제네릭을 통해 타입 안정성을 보장한다

자바 컬렉션 큰 분류

- Collection 계층: List, Set, Queue/Deque
- Map 계층: Map, SortedMap/NavigableMap
- 유틸리티: Arrays, Collections, Optional(별도), Properties 등

---

## **1.1 컬렉션 프레임워크의 핵심 인터페이스**

- Collection: 요소 집합의 최상위 인터페이스이다(List/Set/Queue의 공통 조상)
- List: 순서가 있고 중복을 허용한다(ArrayList, LinkedList 등)
- Set: 중복을 허용하지 않는다(HashSet, TreeSet 등)
- Queue/Deque: 선입선출(FIFO) 또는 양쪽에서 삽입/삭제하는 구조이다(ArrayDeque, LinkedList, PriorityQueue 등)
- Map: 키-값 쌍이다. 키는 중복을 허용하지 않는다(HashMap, TreeMap 등). Collection의 하위가 아니다
- SortedSet/SortedMap, NavigableSet/NavigableMap: 정렬/범위 탐색을 지원한다(TreeSet, TreeMap)

---

## **1.2 ArrayList와 Vector**

- 공통: 동적 배열 기반 리스트이다. 인덱스로 빠르게 접근한다(O(1))
- ArrayList: 동기화를 하지 않아 빠르다. 일반적으로 권장한다
- Vector: 모든 메서드가 동기화되어 있다. 레거시이며 대체로 사용하지 않는다

시간복잡도

- get/set: O(1)
- add(맨끝): 평균 O(1), 필요 시 확장 비용 발생
- add/remove(중간): O(n) (뒤 요소 이동)

예시

```
Java
List<String> files = new ArrayList<>();files.add("보고서.docx");files.add("예산.xlsx");files.remove("예산.xlsx");

```

---

## **1.3 LinkedList**

- 이중 연결 리스트 기반이다. 머리/꼬리에서 삽입·삭제가 빠르다(O(1))
- 임의 인덱스 접근은 느리다(O(n))
- List이자 Deque이다(큐/스택 대용 가능)

예시

```
Java
Deque<String> queue = new LinkedList<>();queue.addLast("메일전송 작업");queue.addLast("백업 작업");queue.pollFirst(); // "메일전송 작업"

```

---

## **1.4 Stack과 Queue**

- Stack: LIFO이다. 레거시 Stack(Vector 기반)은 지양하고 Deque(ArrayDeque)를 사용하는 편이 낫다
- Queue: FIFO이다. 구현으로 LinkedList, ArrayDeque, PriorityQueue 등이 있다

예시

```
Java
// 스택(권장: ArrayDeque)Deque<String> undo = new ArrayDeque<>();undo.push("편집1"); undo.push("편집2");undo.pop(); // "편집2"// 큐Queue<String> tasks = new ArrayDeque<>();tasks.offer("메일 발송"); tasks.offer("리포트 집계");tasks.poll(); // "메일 발송"

```

---

## **1.5 Iterator, ListIterator, Enumeration**

- Iterator: 컬렉션을 순회하는 표준 방식이다(hasNext/next/remove). 동시 수정 시 fail-fast로 ConcurrentModificationException을 던진다
- ListIterator: List 전용 양방향 반복자이다(이전/다음, 인덱스, add/set 지원)
- Enumeration: 레거시 반복자이다(Vector/Hashtable에서 사용). Iterator 사용을 권장한다

예시

```
Java
List<String> emails = List.of("a@x.com", "b@x.com");Iterator<String> it = emails.iterator();while (it.hasNext()) System.out.println(it.next());

```

---

## **1.6 Arrays**

- 배열 유틸리티 클래스이다(정적 메서드 모음)
- 주요 메서드: sort, parallelSort, binarySearch, fill, copyOf, equals/deepEquals, toString/deepToString

예시

```
Java
int[] amounts = {300, 120, 900};Arrays.sort(amounts); // 오름차순int idx = Arrays.binarySearch(amounts, 300); // 존재 위치

```

---

## **1.7 Comparator와 Comparable**

- Comparable: 클래스 자체가 “자연 순서”를 정의한다(compareTo)
- Comparator: 외부에서 정렬 기준을 제공한다. 다양한 기준을 쉽게 바꿀 수 있다
- thenComparing, reversed, nullsFirst/Last 등을 조합한다

예시

```
Java
class Employee implements Comparable<Employee> {  String name; int salary;  public int compareTo(Employee o) { return Integer.compare(this.salary, o.salary); }}List<Employee> list = new ArrayList<>();list.add(new Employee()); // ... 값 설정했다고 가정// 외부 기준: 부서 → 연봉 내림차순Comparator<Employee> byDeptThenSalary =    Comparator.comparing((Employee e) -> eDept(e))  // eDept는 부서 반환 가정              .thenComparing(Comparator.comparingInt((Employee e) -> e.salary).reversed());list.sort(byDeptThenSalary);

```

---

## **1.8 HashSet**

- 중복을 허용하지 않는 집합이다. 해시 기반이라 평균 O(1)로 추가/조회한다
- 순서를 보장하지 않는다. equals/hashCode 계약을 지켜야 정상 동작한다
- null을 하나 허용한다

예시

```
Java
Set<String> sentIds = new HashSet<>();sentIds.add("FILE-2025-001");sentIds.add("FILE-2025-001"); // 추가 안 됨

```

---

## **1.9 TreeSet**

- 정렬된 집합이다(레드-블랙 트리). O(log n)으로 추가/조회한다
- 요소가 Comparable을 구현하거나 생성 시 Comparator를 제공해야 한다
- null을 허용하지 않는다
- 범위 탐색과 이웃 조회가 강점이다(headSet, tailSet, subSet, ceiling/floor 등)

예시

```
Java
NavigableSet<Integer> priorities = new TreeSet<>();priorities.add(3); priorities.add(1); priorities.add(2);priorities.first();  // 1priorities.higher(1); // 2

```

---

## **1.10 HashMap과 Hashtable**

- HashMap: 해시 기반 Map이다. 평균 O(1)로 put/get이 가능하다. null 키 1개, null 값 여러 개 허용한다. 비동기이다
- Hashtable: 레거시 동기화 Map이다. null 키/값을 허용하지 않는다. 새 코드에서는 사용을 지양한다
- 동시성 필요 시 ConcurrentHashMap 사용이 적절하다

예시

```
Java
Map<String, Long> fileSizes = new HashMap<>();fileSizes.put("보고서.docx", 12_345L);long size = fileSizes.getOrDefault("보고서.docx", 0L);// 동시성 대안Map<String, Integer> counter = new java.util.concurrent.ConcurrentHashMap<>();counter.merge("메일", 1, Integer::sum);

```

---

## **1.11 TreeMap**

- 정렬된 Map이다(레드-블랙 트리). O(log n)으로 put/get을 수행한다
- 키가 Comparable을 구현하거나 Comparator가 필요하다
- null 키는 허용하지 않는다
- 범위/이웃 탐색을 지원한다(subMap, headMap, tailMap, floorEntry, higherEntry 등)

예시

```
Java
NavigableMap<String, Integer> inventory = new TreeMap<>();inventory.put("모니터", 5);inventory.put("노트북", 12);inventory.firstEntry();          // ("노트북", 12) — 사전순inventory.subMap("노", true, "사", false); // 범위 맵

```

---

## **1.12 Properties**

- 설정을 키-값(String 중심)으로 다루는 클래스이다. Hashtable을 상속한 레거시지만 여전히 설정 파일에 널리 사용한다
- load/store, loadFromXML/storeToXML을 제공한다
- InputStream으로 로드하는 기본 load는 ISO-8859-1 규칙을 따른다. 한글은 유니코드 이스케이프 또는 Reader 기반 load 사용을 고려한다

예시

```
Java
Properties p = new Properties();try (Reader r = Files.newBufferedReader(Path.of("app.properties"))) {  p.load(r);}String url = p.getProperty("db.url", "jdbc:h2:mem:test");p.setProperty("feature.enabled", "true");try (Writer w = Files.newBufferedWriter(Path.of("app.out.properties"))) {  p.store(w, "saved");}

```

---

## **1.13 Collections**

- 컬렉션 유틸리티 클래스이다(정적 메서드 모음)
- 주요 기능
    - sort, binarySearch, reverse, shuffle, rotate, replaceAll, fill, copy, nCopies
    - frequency, disjoint
    - unmodifiableXXX(읽기 전용 뷰), synchronizedXXX(동기화 래퍼), checkedXXX(런타임 타입 체크)
- 불변 팩토리(Map.of/List.of/Set.of)는 Java 9부터 제공한다

예시

```
Java
List<String> items = new ArrayList<>(List.of("파일","메일","보고"));Collections.shuffle(items);List<String> ro = Collections.unmodifiableList(items); // 읽기 전용 뷰Map<String, Integer> m = Map.of("A",1,"B",2); // 불변 맵

```

---

## **1.14 컬렉션 클래스 정리 & 요약**

- List
    - ArrayList: 임의 접근 빠름, 중간 삽입/삭제 느림, 비동기라 일반적으로 권장한다
    - LinkedList: 중간/양끝 삽입·삭제가 유리, 임의 접근 느리다, Deque 기능을 함께 제공한다
    - Vector/Stack: 레거시 동기화 클래스라 지양한다(대신 ArrayList/ArrayDeque 사용)
- Set
    - HashSet: 해시 기반, 순서 없음, 평균 O(1)
    - LinkedHashSet: 삽입 순서를 유지한다
    - TreeSet: 정렬·범위 탐색, O(log n)
- Map
    - HashMap: 일반적인 선택, null 키 1개 허용
    - LinkedHashMap: 순서 유지(접근 순서 모드로 LRU 캐시 흉내 가능)
    - TreeMap: 정렬·범위 탐색, O(log n)
    - Hashtable: 레거시, 지양
    - ConcurrentHashMap: 동시성에 적합
- Queue/Deque
    - ArrayDeque: 가볍고 빠른 데크, 스택/큐 대용으로 권장
    - LinkedList: 데크 겸용
    - PriorityQueue: 우선순위 큐
- 유틸리티
    - Arrays/Collections: 정렬, 검색, 변환, 불변·동기화 래퍼 제공
    - Properties: 설정 파일 입출력에 사용

필수 주의점

- equals/hashCode 규약을 지켜야 HashSet/HashMap이 정상 동작한다
- 컬렉션 순회 중 구조 변경은 fail-fast 예외를 유발한다(Iterator.remove 사용 또는 병렬 컬렉션 사용)
- 동시성 요구가 있으면 synchronized 래퍼보다 Concurrent 컬렉션을 우선 고려한다
- 필요한 정렬 기준이 여러 개라면 Comparable 대신 Comparator 조합을 사용한다
- 외부에 노출할 컬렉션은 불변 뷰나 불변 팩토리로 감싸는 편이 안전하다