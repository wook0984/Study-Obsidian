# 자바의 정석 객체지향프로그래밍 (2)

## 상속(inheritance)

### 1.1 상속의 정의와 장점

- **상속**: 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- **문법**: `class Child extends Parent { }`
- **장점**:
    - 코드의 재사용성을 높임
    - 코드의 중복을 제거하여 프로그램의 생산성과 유지보수성 향상
    - 클래스 간 계층적 관계를 구성하여 다형성 구현의 기반

Java

```
class Parent {
    int age;
    
    void print() {
        System.out.println("나이: " + age);
    }
}

class Child extends Parent {  // Parent 클래스 상속
    String name;
    
    void printChild() {
        System.out.println("이름: " + name + ", 나이: " + age);  // 상속받은 age 필드 사용
    }
}
```

### 1.4 단일상속(single inheritance)

- 자바는 다중상속을 지원하지 않음 (한 클래스는 하나의 클래스만 상속 가능)
- 다중상속의 문제점(같은 이름의 메서드 충돌 등)을 방지
- 인터페이스를 통해 다중상속의 효과를 낼 수 있음

### 1.5 Object클래스 - 모든 클래스의 조상

- 모든 클래스는 Object 클래스를 자동으로 상속받음
- Object 클래스의 주요 메서드:
    - `equals(Object obj)`: 객체의 동등성 비교
    - `hashCode()`: 객체의 해시코드 반환
    - `toString()`: 객체의 문자열 표현 반환
    - `clone()`: 객체의 복제본 생성
    - `getClass()`: 객체의 클래스 정보 반환

## 오버라이딩(overriding)

### 2.1 오버라이딩이란?

- 상속받은 조상 클래스의 메서드를 자신에 맞게 변경하는 것
- 메서드의 **선언부는 동일**하게 유지하고 **구현부만 변경**

Java

```
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal {
    @Override  // 오버라이딩을 명시하는 어노테이션
    void sound() {
        System.out.println("멍멍!");
    }
}
```

### 2.2 오버라이딩의 조건

1. 메서드의 선언부(이름, 매개변수, 반환타입)가 조상 클래스와 **일치**해야 함
2. 접근 제어자는 조상 클래스보다 **좁게 변경할 수 없음**
3. 예외는 조상 클래스보다 **많이 선언할 수 없음**

### 2.3 오버로딩 vs. 오버라이딩

- **오버로딩(Overloading)**: 같은 이름의 메서드를 여러 개 정의하는 것 (새로운 메서드 정의)
- **오버라이딩(Overriding)**: 상속받은 메서드의 내용을 변경하는 것 (메서드 재정의)

### 2.4 super

- **super**: 조상 클래스의 멤버를 참조하는 참조변수
- **super()**: 조상 클래스의 생성자 호출

Java

```
class Parent {
    int x = 10;
    
    void method() {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    int x = 20;  // 상속받은 멤버변수 x를 중복 정의
    
    void method() {
        System.out.println("Child method");
    }
    
    void print() {
        System.out.println("x = " + x);         // 자신의 멤버변수 x
        System.out.println("super.x = " + super.x);  // 조상 클래스의 멤버변수 x
        method();         // 자신의 메서드
        super.method();   // 조상 클래스의 메서드
    }
}
```

## 다형성(polymorphism)

### 5.1 다형성이란?

- **다형성**: 하나의 객체가 여러 가지 타입을 가질 수 있는 것
- 자바에서는 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있음

Java

```
class Animal { void move() { /* ... */ } }
class Dog extends Animal { void move() { /* ... */ } }
class Cat extends Animal { void move() { /* ... */ } }

Animal animal1 = new Dog();  // Dog 객체를 Animal 참조변수로 참조
Animal animal2 = new Cat();  // Cat 객체를 Animal 참조변수로 참조

animal1.move();  // Dog의 move() 메서드 실행
animal2.move();  // Cat의 move() 메서드 실행
```

### 5.2 참조변수의 형변환

- 자손타입 → 조상타입 (업캐스팅): 형변환 생략 가능
- 조상타입 → 자손타입 (다운캐스팅): 명시적 형변환 필요

Java

```
Dog dog = new Dog();
Animal animal = dog;  // 업캐스팅: 형변환 생략 가능
Dog dog2 = (Dog)animal;  // 다운캐스팅: 명시적 형변환 필요
```

### 5.3 instanceof연산자

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 확인하는 연산자

Java

```
if (animal instanceof Dog) {
    Dog dog = (Dog)animal;  // 안전한 형변환
    dog.bark();  // Dog 클래스의 메서드 호출
}
```

### 5.5 매개변수의 다형성

- 메서드의 매개변수에 다형성을 적용하면 코드를 간결하게 작성할 수 있음

Java

```
void feed(Animal animal) {
    // 모든 동물을 받을 수 있는 메서드
    animal.eat();  // 실제 인스턴스의 오버라이딩된 메서드 호출
}

feed(new Dog());  // Dog 인스턴스를 전달
feed(new Cat());  // Cat 인스턴스를 전달
```

### 5.6 여러 종류의 객체를 배열로 다루기

- 조상 타입의 배열에 다양한 자손 객체를 저장하여 관리할 수 있음

Java

```
Animal[] animals = new Animal[3];
animals[0] = new Dog();
animals[1] = new Cat();
animals[2] = new Bird();

for (Animal animal : animals) {
    animal.move();  // 각 인스턴스의 오버라이딩된 메서드 호출
}
```

## 추상 클래스(abstract class)

### 6.1 추상클래스란?

- **추상클래스**: 미완성된 클래스, 인스턴스 생성 불가
- 상속을 통해 자손 클래스에서 완성하도록 유도하는 클래스
- `abstract` 키워드를 사용하여 선언

### 6.2 추상메서드(abstract method)

- **추상메서드**: 선언부만 있고 구현부가 없는 메서드
- 자손 클래스에서 반드시 오버라이딩하여 구현해야 함

Java

```
abstract class Animal {
    abstract void sound();  // 추상 메서드
    
    void breathe() {
        System.out.println("숨을 쉽니다.");  // 일반 메서드
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");  // 추상 메서드 구현
    }
}
```

### 6.3 추상클래스의 작성

- 공통된 기능은 추상 클래스에 구현하고, 개별적인 기능은 추상 메서드로 선언
- 실체 클래스들의 공통 기능 재사용성 향상 및 일관된 인터페이스 제공

## 인터페이스(interface)

### 7.1 인터페이스란?

- **인터페이스**: 일종의 추상 클래스, 추상 메서드와 상수만을 멤버로 가짐
- 다중 상속의 효과를 낼 수 있는 수단
- 인터페이스는 인스턴스를 생성할 수 없고, 구현체 클래스를 통해 사용

### 7.2 인터페이스의 작성

Java

```
interface Movable {
    // 상수 (public static final 생략 가능)
    int MAX_SPEED = 100;
    
    // 추상 메서드 (public abstract 생략 가능)
    void move(int x, int y);
    
    // 디폴트 메서드 (Java 8부터)
    default void stop() {
        System.out.println("정지합니다.");
    }
    
    // 정적 메서드 (Java 8부터)
    static boolean isMovable() {
        return true;
    }
}
```

### 7.4 인터페이스의 구현

- `implements` 키워드를 사용하여 인터페이스 구현
- 여러 인터페이스를 동시에 구현할 수 있음

Java

```
class Car implements Movable, Drawable {
    @Override
    public void move(int x, int y) {
        System.out.println("차가 이동합니다.");
    }
    
    @Override
    public void draw() {
        System.out.println("차를 그립니다.");
    }
}
```

### 7.6 인터페이스를 이용한 다형성

- 인터페이스 타입의 참조변수로 구현체 인스턴스를 참조할 수 있음
- 이를 통해 다형성을 구현

Java

```
Movable movable = new Car();  // Car 인스턴스를 Movable 참조변수로 참조
movable.move(10, 20);  // Car의 move() 메서드 호출
```

### 7.7 인터페이스의 장점

1. 개발 시간을 단축시킬 수 있음
2. 표준화가 가능
3. 서로 관계없는 클래스들에게 관계를 맺어줄 수 있음
4. 독립적인 프로그래밍이 가능

# 추가적인 정리

### 제어자(modifier)

- **접근 제어자**: `public`, `protected`, `default`, `private`
    - `public`: 모든 곳에서 접근 가능
    - `protected`: 같은 패키지 + 다른 패키지의 자손 클래스
    - `default`(없음): 같은 패키지 내에서만 접근 가능
    - `private`: 같은 클래스 내에서만 접근 가능
- **그 외 제어자**: `static`, `final`, `abstract`, `synchronized` 등
    - `static`: 클래스 레벨의 멤버 선언
    - `final`: 변경 불가능한 멤버 선언
    - `abstract`: 추상 메서드 또는 추상 클래스 선언

### 예외 처리(Exception Handling)

- 예외 처리를 통해 프로그램의 비정상 종료를 방지하고 정상적인 실행 상태를 유지

Java

```
try {
    // 예외가 발생할 가능성이 있는 코드
    int result = 10 / 0;  // ArithmeticException 발생
} catch (ArithmeticException e) {
    // 예외 처리 코드
    System.out.println("0으로 나눌 수 없습니다: " + e.getMessage());
} finally {
    // 예외 발생 여부와 상관없이 항상 실행되는 코드
    System.out.println("프로그램을 종료합니다.");
}
```

### String과 StringBuffer/StringBuilder

- **String**: 불변(immutable) 클래스, 문자열 연산이 많을 경우 성능 저하
- **StringBuffer**: 가변(mutable) 클래스, 멀티스레드 환경에서 안전(thread-safe)
- **StringBuilder**: 가변(mutable) 클래스, 단일스레드에서 StringBuffer보다 성능이 좋음

Java

```
// String: 매 연산마다 새로운 객체 생성
String str = "Hello";
str += " World";  // 새로운 String 객체 생성

// StringBuilder: 기존 객체 수정
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");  // 기존 객체를 수정
```

### 컬렉션 프레임워크

- 자바에서 자료구조를 구현한 클래스들의 집합
- 주요 인터페이스: `List`, `Set`, `Map`
- `ArrayList`, `LinkedList`, `HashSet`, `HashMap` 등의 구현체 제공

Java

```
// ArrayList 사용 예제
List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Cherry");

for (String fruit : list) {
    System.out.println(fruit);
}
```