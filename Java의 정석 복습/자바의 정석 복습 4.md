## 1. 지네릭스(generics)

### 1.1 지네릭스란?

- 타입을 파라미터로 다루는 문법이다. 컴파일 시 타입 안정성이 올라가고, 캐스팅 코드가 사라진다. 컬렉션을 타입 안정적으로 쓰는 데 결정적이었다.
- 자바의 지네릭은 “타입 소거(type erasure)” 기반이라 런타임엔 대부분의 타입 파라미터 정보가 없다. 이 점이 배열 생성 금지, new T() 금지 같은 제약의 이유다.

### 1.2 지네릭 클래스의 선언

Java

```
class Box<T> {
    private T value;
    public Box(T value) { this.value = value; }
    public T get() { return value; }
    public void set(T v) { this.value = v; }
}

class Pair<K, V> {
    public final K key; public final V value;
    public Pair(K k, V v) { this.key = k; this.value = v; }
}
```

메모: static 컨텍스트에선 타입 파라미터 T를 쓸 수 없다(인스턴스 레벨 요소이므로).

### 1.3 지네릭 클래스의 객체 생성과 사용

Java

```
Box<Integer> bi = new Box<>(10);  // 다이아몬드 연산자
int x = bi.get();                 // 언박싱

var names = new ArrayList<String>(); // JDK 10+ var와 같이
names.add("Kim");
```

메모: 기본형은 타입 인자로 못 쓴다. 반드시 래퍼(Integer/Long 등)를 써야 한다. 대량 루프에선 박싱 오버헤드가 실측 차이를 만든다.

### 1.4 제한된 지네릭 클래스(바운드)

- 타입 파라미터에 상한을 걸어 API 의도를 드러내고, 내부 구현에서 해당 메서드를 안전하게 호출할 수 있게 한다.

Java

```
class Stats<T extends Number & Comparable<T>> {
    private final T[] nums;
    Stats(T[] nums) { this.nums = nums; }
    double avg() {
        double s = 0; for (T n : nums) s += n.doubleValue();
        return s / nums.length;
    }
}
```

메모: 클래스 상한은 하나만, 인터페이스는 여러 개 “&”로 연결 가능. 반대로 “super”는 바운드에선 못 쓰고, 와일드카드에서만 쓴다.

### 1.5 와일드 카드

- 제네릭은 무공변(invariant)이라 List<Number>와 List<Integer>는 호환되지 않는다. 이때 와일드카드로 읽기/쓰기 의도를 명확히 표현한다(PECS: Producer Extends, Consumer Super).

Java

```
static double sumOf(List<? extends Number> src) { // 읽기 전용 원천
    double s = 0; for (Number n : src) s += n.doubleValue(); return s;
}

static <T> void copy(List<? extends T> src, List<? super T> dst) { // 쓰기 대상
    for (T t : src) dst.add(t);
}

List<String> b = new ArrayList<>();
List<? extends Object> c = b; // 읽기는 가능하지만 c.add(...)는 거의 금지
```

메모: `List<?>`는 add(null)만 허용된다. 사실상 읽기 전용 뷰라고 보면 이해가 쉽다.

### 1.6 지네릭 메서드

- 메서드 자체가 타입 매개변수를 가질 수 있고, static 메서드에서도 사용 가능하다.

Java

```
static <T extends Comparable<? super T>> T max(List<T> list) {
    T best = list.get(0);
    for (T e : list) if (e.compareTo(best) > 0) best = e;
    return best;
}
String m = MyUtil.<String>max(List.of("a", "zzz", "bb")); // 타입 witness
```

메모: 제네릭+가변인자는 힙 오염 경고가 날 수 있다. 진짜 안전한 경우에만 @SafeVarargs로 억제한다.

### 1.7 지네릭 타입의 형변환

- List<Integer>를 List<Number>로 캐스팅할 수 없다. 와일드카드를 써서 의도를 표현하는 게 정석이다.
- 로(raw) 타입 다운캐스팅은 경고를 없애지만 힙 오염 위험이 크다.

Java

```
List<Integer> ints = new ArrayList<>();
List raw = ints;      // raw 타입
raw.add("oops");      // 경고는 없어도
Integer n = ints.get(0); // 런타임 ClassCastException
```

### 1.8 지네릭 타입의 제거(Type Erasure)

- 컴파일 후 타입 파라미터 정보가 지워지므로 다음이 불가능하다: `new T()`, `new T[]`, `instanceof List<String>`, `List<String>[] arr = new List<String>[10]`.
- 보편적인 우회는 “타입 토큰”이나 Supplier(팩토리) 주입이다.

Java

```
class Store<T> {
    private final Supplier<T> factory;
    Store(Supplier<T> factory) { this.factory = factory; }
    T newInstance() { return factory.get(); }
}
var s = new Store<>(ArrayList<String>::new);
```

메모: 브릿지 메서드(bridge method)는 타입 소거로 인한 오버라이딩 일관성 유지를 위해 컴파일러가 삽입한다. 디버깅 중 보여도 놀라지 말자.

---

## 2. 열거형(enum)

### 2.1 열거형이란?

- 상수 집합을 타입으로 안전하게 표현한다. 각 상수는 싱글턴 객체이고, name()/ordinal()/values()를 제공한다. switch와도 잘 맞고, EnumSet/EnumMap은 성능·메모리 면에서 효율적이었다.

### 2.2 열거형의 정의와 사용

Java

```
enum Direction { NORTH, EAST, SOUTH, WEST }

Direction d = Direction.NORTH;
switch (d) {
    case NORTH -> System.out.println("↑");
    case EAST  -> System.out.println("→");
    case SOUTH -> System.out.println("↓");
    case WEST  -> System.out.println("←");
}
for (Direction x : Direction.values()) System.out.println(x.name());
```

### 2.3 열거형에 멤버 추가하기

- enum도 필드/생성자/메서드를 가질 수 있다. 상수별로 다른 동작을 줄 때 “상수별 클래스 본문”이 유용했다.

Java

```
enum Operation {
    PLUS("+")  { public double apply(double a,double b){ return a+b; } },
    MINUS("-") { public double apply(double a,double b){ return a-b; } },
    TIMES("*") { public double apply(double a,double b){ return a*b; } },
    DIV("/")   { public double apply(double a,double b){ return a/b; } };
    private final String symbol;
    Operation(String symbol) { this.symbol = symbol; }
    public String symbol() { return symbol; }
    public abstract double apply(double a, double b);
}
```

### 2.4 열거형의 이해 포인트

- ordinal()에 의존한 저장/프로토콜은 깨지기 쉽다. 반드시 별도 필드나 name()을 쓰기로 했다.
- enum은 다른 클래스를 상속할 수 없고(이미 Enum 상속), 인터페이스는 구현 가능하다.
- EnumSet/EnumMap은 비트 플래그보다 안전하고 빠르게 동작했다.

---

## 3. 애너테이션(annotation)

### 3.1 애너테이션이란?

- 코드 요소에 메타데이터를 붙이는 수단이다. 컴파일러 힌트, 프레임워크 설정, 런타임 리플렉션 등에서 활용된다. 보존 범위(@Retention)와 타깃(@Target)을 정확히 잡는 게 중요했다.

### 3.2 표준 애너테이션

Java

```
@Override
public String toString() { return "..."; }

@Deprecated(since="1.2", forRemoval = true)
void oldApi() {}

@SuppressWarnings({"unchecked","deprecation"})
void useLegacy() {}

@FunctionalInterface
interface Converter<F,T> { T convert(F from); }

@SafeVarargs // 진짜 안전할 때만
static <T> List<T> of(T... ts) { return List.of(ts); }
```

### 3.3 메타 애너테이션

- @Retention(SOURCE|CLASS|RUNTIME): 어디까지 살아남을지
- @Target: TYPE, METHOD, FIELD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE, MODULE, TYPE_USE, TYPE_PARAMETER, RECORD_COMPONENT 등
- @Documented: Javadoc 포함
- @Inherited: 하위 클래스가 상속
- @Repeatable: 반복 적용

Java

```
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
@Documented
@interface Audited { String value() default "default"; }
```

메모: Java 21에서도 RECORD_COMPONENT, MODULE 타깃을 그대로 활용한다. 타입 애너테이션(TYPE_USE)도 범용적이라, 제네릭/타입 변수에도 붙일 수 있다.

### 3.4 애너테이션 타입 정의하기

- 요소 타입은 제한적이다(기본형, String, Class, enum, 다른 애너테이션, 이들의 배열).

Java

```
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface JsonType {
    String name();
    boolean snakeCase() default false;
    Class<?> serializer() default Void.class;
}

@JsonType(name="user", snakeCase = true)
class User { /* ... */ }

// 리플렉션
var jt = User.class.getAnnotation(JsonType.class);
System.out.println(jt.name()); // "user"
```

메모: 컴파일 단계에서 애너테이션 프로세서로 코드 생성/검증(MapStruct, AutoService 등)을 붙이면 생산성이 크게 올라갔다.

---

## 4. 레코드(record)

### 4.1 레코드란?

- 불변 데이터 캐리어를 매우 간결하게 정의하는 클래스 문법이다(JDK 16 정식, 21에서도 동일). 선언만 하면 생성자/접근자/equals/hashCode/toString이 자동 생성된다.

Java

```
public record Point(int x, int y) {}
var p = new Point(10, 20);
System.out.println(p.x()); // 10
```

### 4.2 레코드의 특징

- 모든 필드는 private final, 클래스는 암묵적으로 final이다. java.lang.Record를 상속(다른 클래스 상속 불가, 인터페이스 구현 가능).
- 불변식 검증은 compact(간결) 생성자에 넣는 게 깔끔했다.

Java

```
public record Email(String local, String domain) {
    public Email {
        if (local == null || domain == null) throw new IllegalArgumentException();
        if (!domain.contains(".")) throw new IllegalArgumentException("bad domain");
    }
}
```

메모: 인스턴스 필드를 추가로 선언할 수 없다(상태는 컴포넌트로만 정의). static 멤버는 가능.

### 4.3 레코드의 중첩

- 정적 중첩/지역 레코드가 가능해 한정된 스코프의 데이터 캐리어를 만들기 좋았다.

Java

```
class Order {
    public static record Item(String sku, int qty) {}
    void process() {
        record Result(boolean ok, String msg) {}
        // ...
    }
}
```

### 4.4 지네릭 레코드

Java

```
public record Box<T>(T value) {}
public record Wrapper<T extends Number>(T value) {}
```

메모: equals/hashCode는 컴포넌트 기반으로 자동 생성된다. 커스터마이징은 신중하게.

### 4.5 레코드와 애너테이션

- 컴포넌트에 직접 애너테이션을 붙일 수 있다(RECORD_COMPONENT 타깃).

Java

```
record User(@NotNull String id, String name) {}
```

메모: JDK 21에서는 “레코드 패턴(Record Patterns)”과 “switch 패턴 매칭”이 정식이라, 레코드 해체(deconstruction)를 switch에서 바로 쓸 수 있다. 실무에서 DTO 해체에 정말 편했다.

Java

```
static String render(Point p) {
    return switch (p) {
        case Point(int x, int y) -> "Point(" + x + "," + y + ")";
    };
}
```

---

## 5. 실드 클래스(sealed class)

### 5.1 실드 클래스란?

- 상속 가능한 하위 타입을 명시적으로 제한하는 문법이다(JDK 17 정식, 21에서도 동일). 도메인 모델의 합유형(variant)을 닫힌 집합으로 안전하게 표현할 수 있었다.

Java

```
public sealed interface Shape permits Circle, Rect, Poly {}

public record Circle(double r) implements Shape {}
public record Rect(double w, double h) implements Shape {}
public non-sealed class Poly implements Shape { /* 이후 자유 확장 허용 */ }
```

### 5.2 실드 클래스의 제약 조건

- sealed 타입과 permitted 하위 타입은 “같은 모듈”에 있어야 한다(모듈을 쓰지 않으면 같은 패키지).
- 하위 타입은 반드시 final, sealed, non-sealed 중 하나를 명시해야 한다.
- 리플렉션으로도 isSealed() 등으로 확인 가능하다.

### 5.3 실드 클래스와 switch식(패턴 매칭)

- JDK 21에서 “switch 패턴 매칭”이 정식이라, sealed 계층과 결합하면 switch가 완전성(exhaustiveness) 체크를 자동으로 보장해 준다. 레코드 패턴과 함께 쓰면 특히 깔끔하다.

Java

```
static double area(Shape s) {
    return switch (s) {
        case Circle c      -> Math.PI * c.r() * c.r();
        case Rect(var w,h) -> w * h; // 레코드 패턴의 var 묶음도 가능
        case Poly p        -> polygonArea(p);
    }; // 모든 하위 타입을 처리하므로 default가 필요 없다
}
```

메모: 과거엔 instanceof 체인+다운캐스팅을 했지만, 21에선 switch 패턴 매칭이 정답이었다. 누락 시 컴파일 단계에서 잡힌다.

---

## 6. 모듈(module)

### 6.1 모듈이란?

- JDK 9의 JPMS는 “명시적 의존성 + 강한 캡슐화”를 제공한다. 어떤 패키지를 공개(exports)하고 어떤 모듈을 요구(requires)하는지 선언으로 관리한다. 거대한 클래스패스 충돌을 줄이는 데 유용했다.

### 6.2 모듈 설명자(module-info.java)

Java

```
module com.example.app {
    requires com.example.util;
    requires transitive com.example.db; // 소비자에게도 전파되는 의존
    exports com.example.api;
    opens com.example.internal to com.fasterxml.jackson.databind; // 리플렉션 허용
    uses com.example.spi.Payment;
    provides com.example.spi.Payment with com.example.pay.CardPayment;
}
```

메모: `open module ...`로 모듈 전체를 리플렉션에 열 수 있지만, 보안/캡슐화 측면에서 `opens`로 필요한 패키지만 여는 게 낫다.

### 6.3 이름없는 모듈과 java.base 모듈

- 클래스패스에 놓인 코드는 “이름없는 모듈(unnamed module)”. 이름없는 모듈은 모든 것을 읽을 수 있지만, 다른 모듈이 그것을 requires할 수는 없다.
- `java.base`는 모든 모듈이 암묵적으로 의존한다(java.lang, java.util 등 기본 API 포함).

### 6.4 전이적 의존성과 순환 의존성

- `requires transitive`는 A→B, B→C(transitive)일 때 A의 소비자가 C를 별도 명시 없이 쓰도록 해 준다.
- 모듈 간 순환 의존은 금지다(A↔B). 구조를 재설계하거나 인터페이스 분리를 고려해야 한다.

### 6.5 모듈의 컴파일과 실행

프로젝트 레이아웃 예

text

```
src
 ├─ com.example.util
 │   ├─ module-info.java
 │   └─ com/example/util/Strings.java
 └─ com.example.app
     ├─ module-info.java
     └─ com/example/app/Main.java
```

컴파일/패키징/실행

Bash

```
# 컴파일
javac --release 21 --module-source-path src -d out -m com.example.util,com.example.app

# JAR 만들기
jar --create --file mods/com.example.util@1.0.jar -C out/com.example.util .
jar --create --file mods/com.example.app@1.0.jar  -C out/com.example.app  .

# 실행
java --module-path mods -m com.example.app/com.example.app.Main
```

메모: 모듈 경로와 클래스패스를 섞으면 해석이 꼬일 수 있다. 한 흐름에서는 일관되게 모듈 경로를 유지하는 게 안전했다.

### 6.6 자동 모듈

- 클래스패스용 JAR을 모듈 경로에 두면 “자동 모듈”이 된다. 이름은 JAR 파일명이나 MANIFEST의 Automatic-Module-Name에서 가져오고, 모든 패키지를 자동 export한다.
- 과도기엔 편리하지만, split package/이름 충돌 위험이 있다. 목표는 명시적 모듈로 전환하는 것.