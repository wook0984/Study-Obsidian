## 준비

- 실행
    - 크롬 → F12 → Console 탭에서 코드 입력/실행
    - 또는 HTML에 <script> 태그로 작성
- 기본 규칙
    - 변수는 let/const를 사용하고 var는 레거시로 간주한다.
    - 값이 변하지 않으면 const, 변할 수 있으면 let을 사용한다.
    - alert/confirm/prompt는 데모나 내부 도구에서만 제한적으로 사용한다.

---

## 1.1 자바스크립트의 역사

- 원문
    - Javascript는 1995년에 Brendan Eich가 발명. ECMA가 1997에 표준화
    - ECMA5, 6가 주로 사용됨.(최신 버젼은 ECMA9)
- 업데이트/정정
    - 표기는 ECMAScript(ES)가 정확하다. ES2015(=ES6) 이후 매년 릴리스되며, 현재는 ES2024까지 공개되었다.
- 설명
    - 자바스크립트는 웹의 표준 언어이며, 브라우저와 서버(Node.js) 모두에서 사용한다.

---

## 1.2 출력과 입력

- 원문
    - window.alert(내용) – 경고창
    - console.log(내용) – 콘솔
    - document.write(내용) – HTML 페이지에 출력
    - 태그.innerHTML = 내용; / 태그.textContent = 내용
    - window.confirm(메시지) – 예/아니오(true/false)
    - window.prompt("제목","내용") – 문자열 또는 ""/null
- 업데이트/정정
    - document.write는 사용을 지양한다(파싱 이후 호출 시 문서를 덮어쓸 수 있다). 텍스트는 textContent를 권장하고, HTML 조각은 신뢰된 경우에만 innerHTML을 사용한다.
- 설명
    - 실제 서비스에서는 콘솔 로그와 DOM 조작이 주로 사용되며, alert류는 사용자 경험을 저해하므로 제한적으로 사용한다.
- 예시
    
    JavaScript
    
    ```
    console.log('업로드 완료');
    const el = document.querySelector('#status');
    el.textContent = '처리 중...'; // 안전
    // el.innerHTML = userInput;   // 사용자 입력을 그대로 넣는 것은 XSS 위험
    ```
    

---

## 1.3 자료형(Data Types)

- 원문
    - typeof로 타입 확인(객체는 instanceof)
    - true로 평가: false가 아닌 값 전부 / false로 평가: 0, -0, "", null, false, NaN, undefined
    - 기본형: number, string, boolean / 기타: null, undefined, symbol(ES6) / 파생형: object, function
    - 배열, 함수도 객체. 단 함수의 typeof는 "function"
- 업데이트/정정
    - 기본형에 bigint가 추가되었다: number, string, boolean, null, undefined, symbol, bigint
    - typeof null === "object"(역사적 이유)에 유의한다.
    - falsy에는 0n(BigInt 0)도 포함된다.
- 설명
    - !!값으로 truthy/falsy를 빠르게 판정한다.
- 예시
    
    JavaScript
    
    ```
    typeof '메일'   // "string"
    typeof 123n     // "bigint"
    !!''            // false
    !!'파일'        // true
    [1,2] instanceof Array // true
    ```
    

---

## 1.4 동적 타입(Dynamic type)

- 원문
    - 변수 타입은 동적으로 결정된다. 값이 없으면 undefined이며, 다른 타입의 값을 저장하면 타입이 바뀐다.
- 설명
    - 한 변수에 숫자와 문자열을 번갈아 담을 수 있으나, 가독성을 위해 일관성을 유지하는 편이 낫다.
- 예시
    
    JavaScript
    
    ```
    let v = 10;    // number
    v = '10';      // string
    typeof v;      // "string"
    ```
    

---

## 1.5 호이스팅(hoisting)

- 원문
    - 변수나 함수의 선언이 해당 범위의 최상단으로 옮겨지는 것
- 업데이트/정정
    - function 선언은 전체 호이스팅되어 선언 전 호출이 가능하다.
    - let/const는 호이스팅되지만 TDZ(Temporal Dead Zone)로 인해 선언 전 접근 시 에러가 발생한다.
- 예시
    
    JavaScript
    
    ```
    hello(); // OK
    function hello(){ console.log('안녕하세요'); }
    
    say(); // ReferenceError
    const say = () => {};
    ```
    

---

## 1.6 변수의 범위(scope)

- 원문
    - 전역 변수(window), 지역 변수(블록범위는 없음)
- 업데이트/정정
    - let/const는 블록 스코프를 가진다. var만 함수 스코프다.
    - 전역 this는 비엄격 스크립트에서 window이고, 모듈/엄격 모드에서는 undefined다.
- 예시
    
    JavaScript
    
    ```
    if (true) {
      let inside = '팀 내부';
    }
    // console.log(inside); // 에러: 블록 바깥
    ```
    

---

## 1.7 형변환(Type conversion)

- 원문
    - 숫자: Number(), parseInt(), parseFloat()
    - 문자열: String()
    - boolean: Boolean(), !!
- 업데이트/정정
    - parseInt는 parseInt(str, 10)처럼 기수를 명시하는 편이 안전하다.
    - BigInt와 Number는 섞어 계산할 수 없다.
- 예시
    
    JavaScript
    
    ```
    Number('100.5');        // 100.5
    parseInt('08', 10);     // 8
    Boolean('');            // false
    Boolean('메일');        // true
    ```
    

---

## 2.1 연산자(Operators)

- 원문
    - 대부분 Java와 동일. 주의할 점이 있다.
- 설명
    - 암묵적 타입 변환과 NaN 비교, === 사용 원칙을 익히면 된다.

### ==와 === (!=, !==)

- 원문
    - ==는 값만 비교, ===는 타입까지 비교. ==는 타입을 일치시킨 후 비교한다.
- 업데이트/정정
    - 실무에서는 ===/!== 사용을 권장한다. NaN은 자기 자신과도 같지 않으므로 Number.isNaN으로 비교한다.
- 예시
    
    JavaScript
    
    ```
    0 == false   // true (권장하지 않음)
    0 === false  // false (권장)
    Number.isNaN(NaN); // true
    ```
    

### 2.2 toExponential(), toFixed(), toPrecision()

- 원문
    - 지정된 소수점 자리수에서 반올림 결과를 문자열로 반환한다.
- 업데이트/정정
    - 사용자 표시 목적이라면 Intl.NumberFormat이 더 편리하다.
- 예시
    
    JavaScript
    
    ```
    (12345.678).toFixed(2);      // "12345.68"
    (12345.678).toPrecision(4);  // "1.235e+4" 또는 "12350"
    new Intl.NumberFormat('ko-KR', { style:'currency', currency:'KRW'}).format(1500000);
    // "₩1,500,000"
    ```
    

---

## 3.1 배열

- 원문
    - 크기는 동적으로 변경 가능. 여러 타입 저장 가능. 배열도 객체이며 new로 생성 가능.
- 업데이트/정정
    - delete arr[i]는 “구멍”을 남기므로 splice로 삭제한다.
- 예시
    
    JavaScript
    
    ```
    const files = ['보고서.docx', '예산.xlsx'];
    files.push('회의록.txt');
    files.splice(1, 1); // '예산.xlsx' 제거
    ```
    

---

## 3.2 배열 – 조건 맞는 요소 찾기, 모든 요소 출력하기

- 원문
    - 찾기: find(), filter(), indexOf()
    - 출력: toString(), join()
- 업데이트/정정
    - includes는 NaN도 찾지만 indexOf는 NaN을 찾지 못한다.
- 예시
    
    JavaScript
    
    ```
    [120, 80, 300].find(s => s > 100);   // 120
    [120, 80, 300].filter(s => s > 100); // [120, 300]
    ['A','B','C'].join(', ');            // "A, B, C"
    ```
    

---

## 3.2 배열 – 요소의 추가와 삭제

- 원문
    - 오른쪽: push(), pop()
    - 왼쪽: unshift(), shift()
    - 가운데: splice(), delete
- 업데이트/정정
    - delete는 요소를 제거하지 않고 빈 칸만 남기므로 splice 사용을 권장한다.
- 예시
    
    JavaScript
    
    ```
    const stages = ['기안', '검토', '승인'];
    stages.splice(1, 1, '재검토'); // ['기안','재검토','승인']
    ```
    

---

## 3.3 배열 – 정렬하기, 뒤집기, 채우기, 합치기

- 원문
    - sort(), reverse(), fill(), concat()
- 업데이트/정정
    - sort 기본은 문자열 정렬이다. 숫자 정렬에는 비교 함수를 제공한다.
    - 원본 보존 최신 메서드: toSorted, toReversed, toSpliced, with, at
- 예시
    
    JavaScript
    
    ```
    [10, 2, 5].sort((a,b)=>a-b); // [2,5,10]
    const nums = [10,2,5];
    nums.toSorted((a,b)=>a-b);   // [2,5,10] (원본 유지)
    nums.at(-1);                 // 마지막 요소
    ```
    

---

## 3.4 다차원 배열

- 원문
    - 배열 안에 배열을 넣어서 구현한다.
- 예시
    
    JavaScript
    
    ```
    const weekly = [
      ['회의', '개발', '리뷰'],  // 월
      ['메일', '개발', '보고'],  // 화
    ];
    weekly[0][2]; // '리뷰'
    ```
    

---

## 4.1 조건문과 반복문

- 원문
    - for문과 while문. switch문은 자바와 동일하나 ===로 비교한다.
- 예시
    
    JavaScript
    
    ```
    const status = '대기';
    if (status === '승인') { /* ... */ }
    else if (status === '대기') { /* ... */ }
    else { /* ... */ }
    
    switch(status){
      case '승인': break;
      case '대기': break;
      default:     break;
    }
    
    const amounts = [100, 200, 300];
    let sum = 0;
    for (const m of amounts) sum += m; // 값 순회
    ```
    

---

## 5.1 함수 – 선언/표현식, IIFE, arguments

- 원문
    - 함수 선언과 호출(항상 값을 반환). 함수 표현식.
    - 즉시 호출 함수 표현식(IIFE).
    - arguments 객체, 선언된 매개변수 수와 인자 수는 달라도 된다. 함수이름.length로 매개변수 개수 확인 가능.
- 업데이트/정정
    - arguments는 유사 배열이므로 나머지 매개변수(...args) 사용을 권장한다.
    - IIFE는 현재 블록 스코프와 ES 모듈이 대체한다.
- 예시
    
    JavaScript
    
    ```
    function add(a, b){ return a + b; }        // 선언식(호이스팅 O)
    const add2 = (a, b) => a + b;              // 화살표
    
    (() => { const once = '한 번만'; })();     // IIFE
    
    function sendMail(...to){ console.log(to.length); } // 나머지 매개변수
    ```
    

---

## 5.2 함수의 오버로딩

- 원문
    - arguments 객체로 자바의 오버로딩을 구현할 수 있다.
- 업데이트/정정
    - JS에는 진짜 오버로딩이 없으므로 인자 타입/개수 점검으로 분기한다.
- 예시
    
    JavaScript
    
    ```
    function report(title, body = '(내용 없음)'){
      return `${title}: ${body}`;
    }
    ```
    

---

## 5.3 함수 – 유효성검사와 매개변수 초기화

- 원문
    - 호출 시 인자가 생략될 수 있으므로 기본값을 넣는다. undefined인지 먼저 확인. typeof x !== "undefined" 형태를 사용한다.
- 업데이트/정정
    - 기본값 매개변수 구문을 우선 사용하고, 외부 변수 존재 여부는 typeof로 방어한다.
- 예시
    
    JavaScript
    
    ```
    function book(time='09:00', attendees=[]){
      if (!Array.isArray(attendees)) throw new Error('attendees는 배열이어야 한다.');
    }
    if (typeof 설정 !== 'undefined') { /* 안전한 접근 */ }
    ```
    

---

## 5.4 함수 – 클로저(1/5 ~ 5/5) 요약

- 원문 요지
    - 전역변수는 충돌/노출 위험이 있어 보호가 필요하다.
    - 지역변수는 보호되지만 호출할 때마다 초기화된다.
    - 내부함수를 반환해 외부에서 접근 가능하게 만들면 클로저가 된다.
    - 콜백에서 외부변수를 사용할 때 의도와 다른 결과가 나올 수 있어 클로저나 forEach로 해결한다.
- 설명
    - 클로저는 함수가 생성될 때의 “환경(변수)”을 기억하는 능력이다.
- 예시
    
    JavaScript
    
    ```
    function makeCounter(){
      let tries = 0;               // 외부에서 직접 변경 불가
      return () => ++tries;        // 내부함수가 tries를 기억
    }
    const next = makeCounter();
    next(); // 1
    next(); // 2
    
    for (let i = 0; i < 3; i++) {
      setTimeout(() => console.log('메일', i), 0); // 0,1,2
    }
    ```
    

---

## 6.1 객체의 생성방법

- 원문
    - 1. 빈 객체 생성 후 멤버 추가 2) 생성과 동시에 멤버 추가
- 예시
    
    JavaScript
    
    ```
    const file = {};
    file.name = '보고서.docx'; file.size = 12345;
    
    const employee = { name:'김대리', dept:'영업', email:'kim@company.com' };
    ```
    

---

## 6.2 생성자로 객체생성하기

- 원문
    - 생성자를 정의하면 객체를 편리하게 생성할 수 있다.
- 업데이트/정정
    - 현대 자바스크립트에서는 class 문법 사용을 권장한다.
- 예시
    
    JavaScript
    
    ```
    class Employee {
      constructor(name){ this.name = name; }
      say(){ return `안녕하세요 ${this.name}`; }
    }
    const e = new Employee('민수');
    ```
    

---

## 6.3 객체의 속성(멤버) 삭제하기 - delete

- 원문
    - delete 연산자로 객체의 속성을 삭제(상속 속성은 삭제 불가)
- 예시
    
    JavaScript
    
    ```
    delete employee.dept;
    ```
    

---

## 6.4 instanceof와 typeof

- 원문
    - instanceof로 어떤 생성자에 의해 생성되었는지 확인 가능
- 예시
    
    JavaScript
    
    ```
    e instanceof Employee; // true
    typeof employee;       // "object"
    ```
    

---

## 6.5 같은 타입의 객체라도 함수를 공유안함.

- 원문
    - 같은 생성자로 생성한 객체라도 서로 다른 함수를 가질 수 있다.
- 업데이트/정정
    - 인스턴스에 메서드를 직접 정의하면 각자 복사본을 가지므로 비효율적이다. 프로토타입(또는 클래스 메서드)에 정의해 공유하는 것이 일반적이다.
- 예시
    
    JavaScript
    
    ```
    function Emp(name){ this.name = name; this.say = ()=>'hi'; } // 인스턴스 메서드(비권장)
    Emp.prototype.work = function(){ return '일함'; };            // 공유(권장)
    ```
    

---

## 6.6 prototype, **proto**, constructor

- 원문
    - 객체는 __proto__와 constructor 속성을 자동으로 가진다.
- 업데이트/정정
    - __proto__는 레거시다. Object.getPrototypeOf / setPrototypeOf 사용을 권장한다.
- 예시
    
    JavaScript
    
    ```
    const proto = Object.getPrototypeOf(e);
    ```
    

---

## 6.7 생성자의 prototype을 이용한 함수 공유

- 원문
    - 생성자의 prototype에 함수를 추가하면 공유가 가능하다.
- 예시
    
    JavaScript
    
    ```
    Employee.prototype.approve = function(){ return `${this.name} 승인`; };
    ```
    

---

## 6.8 객체를 의미하는 this

- 원문
    - this는 기본적으로 함수를 호출하는 객체를 의미. 전역 범위의 this는 window
- 업데이트/정정
    - 모듈/엄격 모드 전역 this는 undefined다. 화살표 함수는 자체 this가 없고 바깥 this를 캡처한다.
- 예시
    
    JavaScript
    
    ```
    const obj = { name:'보고', print(){ console.log(this.name); } };
    obj.print(); // '보고'
    ```
    

---

## 6.9 call(), apply()로 this의 대상 변경

- 원문
    - call(), apply(), bind()로 this를 변경할 수 있다.
- 예시
    
    JavaScript
    
    ```
    function info(){ console.log(this.name); }
    info.call({name:'계약'});          // 계약
    info.apply({name:'결재'});         // 결재
    const bound = info.bind({name:'송장'});
    bound();                           // 송장
    ```
    

---

## 6.10 중첩된 함수에서의 this

- 원문
    - 중첩되면 this의 의미가 달라지므로 별도 변수에 저장한다.
- 업데이트/정정
    - 화살표 함수를 사용하면 바깥 this를 그대로 사용한다.
- 예시
    
    JavaScript
    
    ```
    const team = {
      name:'개발',
      run(){
        setTimeout(() => console.log(this.name), 0); // '개발'
      }
    };
    team.run();
    ```
    

---

## 6.11 HTML과 jQuery에서의 this

- 원문
    - this는 상황에 따라 달라진다.
- 업데이트/정정
    - addEventListener에 전통 function을 쓰면 this는 이벤트 대상 요소다. 화살표 함수에서는 this가 요소가 아니므로 e.currentTarget 사용이 안전하다.
- 예시
    
    JavaScript
    
    ```
    btn.addEventListener('click', function(){ console.log(this === btn); }); // true
    ```
    

---

## 6.12 객체의 속성에 접근 제한하기

- 원문
    - 생성자의 변수를 지역변수로 선언해 접근을 제한하고 getter를 제공한다.
- 업데이트/정정
    - class의 private 필드(#)로 간단히 캡슐화할 수 있다.
- 예시
    
    JavaScript
    
    ```
    class Account {
      #balance = 0;
      deposit(n){ this.#balance += n; }
      get balance(){ return this.#balance; }
    }
    ```
    

---

## 6.13 두 객체간의 상속관계 맺어주기

- 원문
    - Person과 Manager를 조상-자손 관계로 맺는다.
- 업데이트/정정
    - class extends 문법을 사용한다.
- 예시
    
    JavaScript
    
    ```
    class Manager extends Employee {
      constructor(name, team){ super(name); this.team = team; }
      approve(){ return `${this.name} 승인`; }
    }
    ```
    

---

## 7.1 DOM(Document Object Model) (1/4) — 개요

- 원문
    - 브라우저는 HTML 문서를 읽어서 DOM을 구성한다.
- 설명
    - DOM은 화면 요소를 코드로 다룰 수 있는 트리 구조다.

### 7.1 (2/4) — 요소 찾기/변경

- 원문
    - 찾기: getElementById, getElementsByTagName/ClassName/Name, querySelector(All)
    - 변경: innerHTML, style.CSS속성, setAttribute/getAttribute
- 업데이트/정정
    - CSS 속성은 카멜케이스로 접근한다(element.style.backgroundColor). 사용자 입력은 textContent로 넣고, innerHTML은 신뢰된 HTML에만 사용한다.
- 예시
    
    JavaScript
    
    ```
    const el = document.querySelector('#status');
    el.textContent = '메일 전송됨';
    el.style.backgroundColor = 'skyblue';
    el.setAttribute('data-id', 'A1');
    ```
    

### 7.1 (3/4) — 생성/추가/삭제

- 원문
    - createElement, createTextNode, appendChild, removeChild, replaceChild
- 업데이트/정정
    - 최신 API인 append, prepend, before, after, remove, replaceWith가 간단하다.
- 예시
    
    JavaScript
    
    ```
    const li = document.createElement('li');
    li.textContent = '계약서.pdf';
    list.append(li);
    // li.remove();
    ```
    

### 7.1 (4/4) — 순회

- 원문
    - firstChild, lastChild, parentNode, nextSibling, previousSibling
- 업데이트/정정
    - 텍스트 노드를 제외하려면 Element 전용 접근자(firstElementChild, nextElementSibling 등)를 사용한다.
- 예시
    
    JavaScript
    
    ```
    el.parentElement; el.firstElementChild; el.nextElementSibling;
    ```
    

---

## 7.2 이벤트(event)

- 원문(대표)
    - onload, onclick, onmouseover, onmouseout, onkeydown, onchange
- 업데이트/정정
    - 인라인 속성(onclick=…) 대신 addEventListener 사용을 권장한다.
- 예시
    
    JavaScript
    
    ```
    const link = document.querySelector('a.download');
    link.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('파일 준비 중...');
    });
    ```
    

---

## 7.3 이벤트 모델

- 원문
    - DOM Level 0(고전) / 인라인 / DOM Level 2(표준) / IE 이벤트 모델
- 업데이트/정정
    - 현대 브라우저에서는 addEventListener/removeEventListener만 고려해도 충분하다.
- 예시
    
    JavaScript
    
    ```
    // 고전: btn.onclick = handler;  // 하나만 등록
    // 표준:
    btn.addEventListener('click', handler);     // 여러 개 등록 가능
    ```
    

---

## 7.4 디폴트 이벤트 제거

- 원문
    - 일부 태그의 기본 이벤트는 처리함수가 false를 반환하면 제거된다.
    - form onsubmit에서 검사 후 전송한다.
- 업데이트/정정
    - addEventListener에서는 return false가 동작하지 않는다. e.preventDefault()를 사용한다.
- 예시
    
    JavaScript
    
    ```
    form.addEventListener('submit', (e) => {
      if (!agree.checked) { e.preventDefault(); alert('약관 동의 필요'); }
    });
    ```
    

---

## 7.5 이벤트 전달(event propagation)

- 원문
    - 특정 요소에서 발생한 이벤트가 부모나 자손 요소로 전달될 수 있다. 부모로 전달되는 것을 버블링이라 한다.
- 설명
    - 캡처링은 부모→자식, 버블링은 자식→부모 순서다. 기본은 버블링이며, 캡처링은 옵션으로 활성화한다.
- 예시(이벤트 위임)
    
    JavaScript
    
    ```
    list.addEventListener('click', (e) => {
      const item = e.target.closest('li');
      if (!item) return;
      console.log('클릭한 파일:', item.textContent);
    });
    ```
    

---

## 7.6 이벤트 전달 – 중단시키기

- 원문
    - event.cancelBubble = true
- 업데이트/정정
    - 표준 API는 e.stopPropagation()이며, 필요 시 e.stopImmediatePropagation()을 사용한다.
- 예시
    
    JavaScript
    
    ```
    child.addEventListener('click', (e) => e.stopPropagation());
    ```
    

---

## 7.7 DOM Level 2 – 표준 & IE 이벤트 모델

- 원문
    - 표준: addEventListener(이벤트, 처리기, useCapture), removeEventListener
    - IE: attachEvent/detachEvent(캡처링 미지원)
- 업데이트/정정
    - 최신 브라우저는 옵션 객체를 지원한다: { capture, once, passive, signal }
- 예시
    
    JavaScript
    
    ```
    const ac = new AbortController();
    window.addEventListener('scroll', onScroll, { passive:true, once:true, signal: ac.signal });
    // 해제
    ac.abort();
    ```
    

---

## 7.8 DOM Level 2 – 이벤트 모델 실습

- 예시
    
    JavaScript
    
    ```
    // "파일 목록에서 항목 클릭하면 강조, 링크 기본 이동 막기"
    const list = document.querySelector('#files');
    list.addEventListener('click', (e) => {
      const a = e.target.closest('a');
      if (!a) return;
      e.preventDefault();
      list.querySelectorAll('li').forEach(li => li.classList.remove('active'));
      a.closest('li').classList.add('active');
    });
    ```