## 1장. SQL 처리 과정과 I/O

### 1.1 SQL 파싱과 최적화

#### 1.1.1 구조적, 집합적, 선언적 질의 언어

SQL은 세 가지 특징을 가진다:

**구조적(Structured)**

- 데이터가 테이블 구조로 저장되어 있다
- 행(Row)과 열(Column)로 구성된 2차원 구조다

**집합적(Set-based)**

- 한 번에 여러 건을 처리한다
- 절차적 언어처럼 한 건씩 처리하지 않는다

SQL

```
-- 절차적 사고: 고객을 한 명씩 확인해서 서울이면 출력
-- SQL 사고: 서울 고객 집합을 한 번에 가져와!
SELECT * FROM 고객 WHERE 지역 = '서울';
```

**선언적(Declarative)**

- "어떻게(How)"가 아닌 "무엇을(What)" 원하는지만 기술한다
- 실제 처리 방법은 DBMS가 결정한다

"원하는 결과집합을 구조적, 집합적으로 선언하지만, 그 결과 집합을 만드는 과정은 절차적일 수 밖에 없다. 즉, 프로시저가 필요한데, 그런 프로시저를 만들어 내는 DBMS 내부 엔진이 바로 SQL 옵티마이저다. 옵티마이저가 프로그래밍을 대신해 주는 셈이다."   - p.18
#### 1.1.2 SQL 최적화

SQL을 실행하기 전에 최적화 과정을 거친다. 이 과정은 크게 세 단계로 나뉜다.

1. **파싱(Parsing)**
    
    - 문법 검사: SQL 문법이 맞는지 확인
    - 의미 검사: 테이블과 컬럼이 실제로 존재하는지 확인
    - 권한 검사: 사용자가 해당 객체에 접근할 권한이 있는지 확인
    
2. **최적화(Optimization)**
    
    - 실행 계획 생성: 여러 가지 실행 방법을 만들어본다
    - 비용 계산: 각 방법의 예상 비용을 계산한다
    - 최적 계획 선택: 가장 비용이 적은 방법을 선택한다
    
3. **로우 소스 생성**
    
    - SQL 옵티마이저가 선택한 실행 계획대로 실행 가능한 코드 또는 프로시저 형태로 포맷팅한다

#### 1.1.3 SQL 옵티마이저

옵티마이저는 SQL의 실행 계획을 만드는 DBMS의 핵심 엔진이다.

**비용 기반 옵티마이저(CBO)**

- 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
- 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해
  각 실행계획의 예상비용을 산정한다.
- 최저 비용을 나타내는 실행계획을 선택한다.

SQL

```
-- 옵티마이저가 고민하는 상황
SELECT * FROM 주문 WHERE 주문일자 = '2025-08-01';

-- 고민 1: 인덱스를 쓸까? 풀 스캔을 할까?
-- 고민 2: 2025-08-01 주문이 전체의 0.1%면 인덱스 사용
-- 고민 3: 2025-08-01 주문이 전체의 50%면 풀 스캔
```

#### 1.1.4 실행계획과 비용

**실행계획** SQL을 어떻게 수행할지 단계별로 나타낸 것이다.

SQL

```
EXPLAIN PLAN FOR
SELECT e.이름, d.부서명
FROM 직원 e, 부서 d
WHERE e.부서코드 = d.부서코드
AND e.급여 > 5000;

-- 실행계획 예시
1. 직원 테이블에서 급여 > 5000인 직원 찾기 (인덱스 스캔)
2. 찾은 직원의 부서코드로 부서 테이블 조인 (Nested Loop)
3. 결과 반환
```

**비용(Cost)**

- CPU 사용량, 디스크 I/O, 메모리 사용량 등을 종합한 예상 비용이다
- 상대적인 값이며, 낮을수록 좋다
- 실제 수행 시간과 항상 일치하지는 않는다

#### 1.1.5 옵티마이저 힌트

옵티마이저가 잘못된 판단을 할 때 개발자가 직접 지시할 수 있다.

SQL

```
-- 인덱스 사용 강제
SELECT /*+ INDEX(e idx_emp_sal) */ *
FROM 직원 e
WHERE 급여 > 5000;

-- 조인 방법 지정
SELECT /*+ USE_NL(e d) */ *
FROM 직원 e, 부서 d
WHERE e.부서코드 = d.부서코드;

-- 테이블 액세스 방법 지정
SELECT /*+ FULL(e) */ *
FROM 직원 e;
```

### 1.2 SQL 공유 및 재사용

#### 1.2.1 소프트 파싱 vs. 하드 파싱

**하드 파싱**

- SQL을 처음 실행할 때 발생한다
- 파싱, 최적화, 실행계획 생성의 전 과정을 수행한다
- CPU를 많이 사용하고 시간이 오래 걸린다

**소프트 파싱**

- 이전에 실행한 SQL의 실행계획을 재사용한다
- Library Cache에서 동일한 SQL을 찾는다
- 찾으면 바로 실행 단계로 넘어간다

SQL

```
-- 첫 번째 실행: 하드 파싱
SELECT * FROM 고객 WHERE 고객ID = 100;

-- 두 번째 실행: 소프트 파싱 (동일한 SQL)
SELECT * FROM 고객 WHERE 고객ID = 100;

-- 세 번째 실행: 하드 파싱 (다른 SQL로 인식)
SELECT * FROM 고객 WHERE 고객ID = 200;
```

#### 1.2.2 바인드 변수의 중요성

바인드 변수를 사용하면 SQL을 재사용할 수 있다.

**리터럴 SQL의 문제점**

SQL

```
-- 각각 다른 SQL로 인식되어 매번 하드 파싱
SELECT * FROM 주문 WHERE 주문번호 = 1001;
SELECT * FROM 주문 WHERE 주문번호 = 1002;
SELECT * FROM 주문 WHERE 주문번호 = 1003;
-- ... 수천 개의 서로 다른 SQL이 생성됨
```

**바인드 변수 사용**

SQL

```
-- 하나의 SQL로 인식되어 재사용 가능
SELECT * FROM 주문 WHERE 주문번호 = :order_no;

-- Java 예시
PreparedStatement pstmt = conn.prepareStatement(
    "SELECT * FROM 주문 WHERE 주문번호 = ?"
);
pstmt.setInt(1, 1001);  // 바인드 변수에 값 설정
```

### 1.3 데이터 저장 구조 및 I/O 메커니즘

#### 1.3.1 SQL이 느린 이유

SQL이 느린 가장 큰 이유는 디스크 I/O다.

**속도 차이**

- CPU 캐시: 1나노초
- 메모리: 100나노초
- SSD: 100마이크로초
- HDD: 10밀리초

디스크는 메모리보다 10만 배 이상 느리다!

#### 1.3.2 데이터베이스 저장 구조

**세그먼트(Segment)**

- 테이블, 인덱스 등의 데이터베이스 객체
- 저장 공간을 할당받는 단위

**익스텐트(Extent)**

- 연속된 블록의 집합
- 공간 할당의 단위

**블록(Block)**

- 데이터베이스 I/O의 최소 단위
- 보통 8KB 크기
- 한 블록에 여러 행이 저장된다

text

```
세그먼트 (테이블)
  └─ 익스텐트 1 (64KB = 8블록)
       ├─ 블록 1 (8KB) - 행 1~10
       ├─ 블록 2 (8KB) - 행 11~20
       └─ ...
  └─ 익스텐트 2
       └─ ...
```

#### 1.3.3 블록 단위 I/O

데이터베이스는 블록 단위로 I/O를 수행한다.

SQL

```
-- 한 행만 필요해도 블록 전체를 읽는다
SELECT 이름 FROM 직원 WHERE 직원ID = 100;

-- 직원ID 100이 블록 5에 있다면:
-- 1. 블록 5 전체(8KB)를 메모리로 읽기
-- 2. 블록 5에서 직원ID 100인 행 찾기
-- 3. 이름 컬럼 값 반환
```

#### 1.3.4 시퀀셜 액세스 vs. 랜덤 액세스

**시퀀셜 액세스**

- 논리적/물리적으로 연속된 블록을 읽는다
- 한 번의 I/O로 여러 블록을 읽을 수 있다
- Multi Block I/O가 가능하다

**랜덤 액세스**

- 떨어져 있는 블록을 읽는다
- 한 번에 한 블록씩만 읽는다
- Single Block I/O만 가능하다

SQL

```
-- 시퀀셜 액세스 (Table Full Scan)
SELECT * FROM 직원;  -- 모든 블록을 순서대로 읽기

-- 랜덤 액세스 (Index를 통한 액세스)
SELECT * FROM 직원 WHERE 직원ID = 100;  -- 특정 블록만 읽기
```

#### 1.3.5 논리적 I/O vs. 물리적 I/O

**논리적 I/O**

- 메모리(버퍼 캐시)에서 블록을 읽는 것
- 빠르다 (마이크로초 단위)

**물리적 I/O**

- 디스크에서 블록을 읽는 것
- 느리다 (밀리초 단위)

text

```
사용자 SQL 요청
    ↓
버퍼 캐시 확인
    ↓
있으면: 논리적 I/O (빠름)
없으면: 물리적 I/O (느림) → 버퍼 캐시에 적재
    ↓
결과 반환
```

**버퍼 캐시 히트율**

text

```
히트율 = (논리적 I/O - 물리적 I/O) / 논리적 I/O × 100

예: 논리적 I/O 1000번, 물리적 I/O 50번
히트율 = (1000 - 50) / 1000 × 100 = 95%
```

#### 1.3.6 Single Block I/O vs. Multiblock I/O

**Single Block I/O**

- 한 번에 한 블록씩 읽는다
- 인덱스를 통한 테이블 액세스 시 사용
- 랜덤 액세스에서 발생

**Multiblock I/O**

- 한 번에 여러 블록을 읽는다
- 테이블 풀 스캔 시 사용
- 시퀀셜 액세스에서 발생
- db_file_multiblock_read_count 파라미터로 조정

SQL

```
-- Single Block I/O
SELECT * FROM 직원 WHERE 직원ID = 100;
-- 인덱스 → 테이블: 블록을 하나씩 읽음

-- Multiblock I/O  
SELECT AVG(급여) FROM 직원;
-- 전체 테이블 스캔: 여러 블록을 한 번에 읽음
```

#### 1.3.7 Table Full Scan vs. Index Range Scan

**Table Full Scan**

- 테이블의 모든 블록을 읽는다
- Multiblock I/O를 사용한다
- 많은 데이터를 읽을 때 유리하다

**Index Range Scan**

- 인덱스를 통해 필요한 부분만 읽는다
- Single Block I/O를 사용한다
- 적은 데이터를 읽을 때 유리하다

SQL

```
-- Table Full Scan이 유리한 경우
SELECT * FROM 주문 WHERE 주문일자 >= '2025-08-01';
-- 전체 데이터의 20% 이상이면 풀 스캔이 빠를 수 있다

-- Index Range Scan이 유리한 경우
SELECT * FROM 주문 WHERE 주문번호 = 12345;
-- 한 건만 읽으므로 인덱스가 훨씬 빠르다
```

#### 1.3.8 캐시 탐색 메커니즘

버퍼 캐시에서 블록을 찾는 과정이다.

**해시 체인 구조**

text

```
해시 함수(블록 주소) → 해시 버킷
                      ↓
                    체인 탐색
                      ↓
                    블록 발견
```

**LRU(Least Recently Used) 알고리즘**

- 가장 오래 사용하지 않은 블록을 제거한다
- Hot 영역: 자주 사용하는 블록
- Cold 영역: 자주 사용하지 않는 블록

